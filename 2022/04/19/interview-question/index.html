<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="&lt;%= config.description %)"/><meta name="keyword"/><title>haibolian's blog
-

</title><link rel="icon" href="/img/favicon.ico"/>
<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/helpers.css">
<script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading-wrapper" data-loading="true"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="true"><div class="head" data-show="true"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/">haibolian's blog</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-about" id="head-about"><a class="head-about-link" href="/about">关于</a></div></div></header>
<div class="menu-bar-head" id="menu-bar" data-show="false"><ul class="menu-bar-ul"><li class="menu-bar-item"><a href="/categories/Web/"><span>Web</span></a></li><li class="menu-bar-item"><a href="/categories/Server/"><span>Server</span></a></li><li class="menu-bar-item  border"><a href="/archives"><span>Archives</span></a></li><li class="menu-bar-item"><a href="/tags"><span>Tags</span></a></li><li class="menu-bar-item"><a href="/about"><span>关于</span></a></li></ul></div></div><div class="main"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/2022/04/19/interview-question/">interview</a></h1></header><div class="post-datetag"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2022-04-19 20:27:36" datetime="2022-04-19T12:27:36.098Z">2022-04-19</time></div>|<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li></ul></div>|
<div class="post-visit"><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span>访问</span></div></div><div class="post-word-count">本文共22955字。</div><div class="article-entry" itemprop="articleBody"><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7095899257072254989">直接看这里吧</a></p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="1-css选择器及优先级"><a href="#1-css选择器及优先级" class="headerlink" title="1. css选择器及优先级"></a>1. css选择器及优先级</h2><ol>
<li>id选择器（#id{}）</li>
<li>类名选择器 （.class{}）</li>
<li>属性名选择器 ( div[name&#x3D;’title’] )</li>
<li>伪类选择器 ( div:after, div:before )</li>
<li>子选择器（ div &gt; span ）</li>
<li>相邻元素选择器 ( div + div )</li>
<li>标签选择器（div）</li>
<li>后代选择器（div span）</li>
<li>通配符选择器（*）</li>
</ol>
<p><strong>优先级：</strong><br>!important &gt; 内联式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符 &gt; 继承 &gt; 浏览器默认</p>
<h2 id="2-position-属性的值以及区别"><a href="#2-position-属性的值以及区别" class="headerlink" title="2. position 属性的值以及区别"></a>2. position 属性的值以及区别</h2><ol>
<li>相对定位 - relative： 不脱离文档流， 在元素自身位置进行上下左右的移动。</li>
<li>绝对定位 - absolute：脱离文档流，不占空间，相对于已定位的祖先元素的左上角进行上下左右的移动。如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。</li>
<li>固定定位 - fixed：脱离文档流，不占空间。相对于浏览器窗口固定位置，且不跟随滚动条移动。</li>
<li>粘性定位 - sticky：先按照普通文档流，直到规定位置，然后粘在那里，不脱离文档流。当可以进入文档流时，再加入文档流。</li>
<li>默认定位 - static：没有定位，元素出现在正常的流中。</li>
</ol>
<h2 id="3-css-盒模型"><a href="#3-css-盒模型" class="headerlink" title="3. css 盒模型"></a>3. css 盒模型</h2><p>当对文档进行布局的时候，浏览器会根据基础框盒模型，将所有元素表示为一个个矩形的盒子，css决定这些盒子的大小，位置及属性。<br>每个盒子由四部分组成，内容区域-content、内边距 - padding、边框区域 - border、外边距 - margin。</p>
<ol>
<li>内容区域：容纳着元素的真实内容，例如文本，图像，它的尺寸为内容高度和内容宽度，如果box-sizing为默认的content-box。那么 css 指定的width和height为内容区域的宽度和高度，如果再设置边框和内边距，则会撑大这个元素。</li>
<li>内边距区域：扩展自内容区域，负责延伸内容区域的背景，填充内容和边框的间距。</li>
<li>边框区域： 扩展自内边距区域，容纳边框的区域。如果box-sizing设置为border-box，那么边框和内边距的值，是包含在设定的width和height中的，内容区域的宽度和高度就是这个设定的width和height减去边框和内边距的width和height。</li>
<li>外边距区域： 利用空白区域扩展边框区域，用于和相邻元素分开。</li>
</ol>
<h2 id="4-怎么触发BFC，有什么应用场景？"><a href="#4-怎么触发BFC，有什么应用场景？" class="headerlink" title="4. 怎么触发BFC，有什么应用场景？"></a>4. 怎么触发BFC，有什么应用场景？</h2><p><strong>BFC：</strong> 块级格式化上下文</p>
<p>触发 BFC 条件：当元素满足以下任意一个条件的时候</p>
<ul>
<li>body 根元素</li>
<li>设置浮动，不包括 none</li>
<li>设置定位，absolute 或者 fixed</li>
<li>行内块显示模式：inline-block</li>
<li>设置 overflow，hidden、auto、scroll</li>
<li>表格单元格，table-cell</li>
<li>flex</li>
</ul>
<p>一个BFC区域，只包含其所有子元素，不包含子元素的子元素。</p>
<p>BFC有一个<strong>特点</strong>是：<strong>每一个BFC区域都是相互独立，互不影响的。</strong></p>
<p><strong>利用 BFC 场景</strong></p>
<ul>
<li><p>解决外边距塌陷问题</p>
<p>当两个 div 的 margin 引起塌陷问题时，可以把他们分别放到两个 BFC 区域中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两个 margin 都是 100px 会引起塌陷 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;HT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;HT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 利用 BFC 包裹起来 .HT_BFC =&gt; overflow:hidden --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;HT_BFC&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;HT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;HT_BFC&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;HT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决包含塌陷</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- son 设置 margig-top，会把 parent 一起带下去 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>清除浮动</p>
<p>父元素设置 <code>overflow:hidden</code></p>
</li>
<li><p>阻止标准流元素被浮动元素覆盖</p>
</li>
</ul>
<h2 id="5-flex-布局"><a href="#5-flex-布局" class="headerlink" title="5. flex 布局"></a>5. flex 布局</h2><p>flex 布局是弹性布局。任何元素都可以使用 flex 布局，包括行内元素。</p>
<p>父元素设为 flex 布局后，</p>
<ul>
<li>其子元素的 float、clear、vertical-align 属性失效;</li>
<li>子元素默认沿主轴方向排列；</li>
</ul>
<p><strong>父元素拥有以下几个属性</strong>：</p>
<ol>
<li><strong>flex-direction</strong>：主轴的方向<ul>
<li>row（默认值）： 主轴为水平方向，起点在左端</li>
<li>column：主轴为垂直方向，起点在上端</li>
<li>row-reverse：主轴为水平方向，起点在右端</li>
<li>column-reverse：column：主轴为垂直方向，起点在下端</li>
</ul>
</li>
<li><strong>flex-wrap</strong>：规定如果子元素在主轴方向放不下，该如何换行<ul>
<li>nowrap：不换行，默认值</li>
<li>wrap：换行，第一行在上方</li>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
</li>
<li><strong>flex-flow</strong>：flex-direction 和 flex-wrap 的简写，默认值为 <code>row nowrap</code></li>
<li><strong>justify-content</strong>： 主轴上的对其方式，假设主轴方向从左到右：<ul>
<li>flex-start：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-between：两端对齐</li>
<li>space-around：每个子元素两侧的间隔相等。（那么，项目与项目之间的间隔比项目与边框的间隔大一倍）</li>
</ul>
</li>
<li><strong>align-items</strong>：子元素沿交叉轴的对其方式<ul>
<li>flex-start：沿交叉轴起点对其</li>
<li>flex-end：沿交叉轴终点对其</li>
<li>center：沿交叉轴中点对齐</li>
<li>baseline：沿子元素第一行文字的基线对齐</li>
<li>stretch（默认值）：如果子元素没设置高度或者设置为 auto，则占满容器的整个高度</li>
</ul>
</li>
<li><strong>align-content</strong>：子元素很多导致换行，有多根轴线时的对其方式。如果子元素只有一根轴线，则不起作用<ul>
<li>flex-start：与交叉轴起点对齐</li>
<li>flex-end：与交叉轴终点对齐</li>
<li>center：与交叉轴中点对齐</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around：每根轴线两测间隔相等</li>
</ul>
</li>
</ol>
<p><strong>子元素拥有以下几个属性</strong>：</p>
<ol>
<li><p><strong>order</strong>：子元素的排列顺序，数值越小，排列越靠前，默认为 0</p>
</li>
<li><p><strong>flex-grow</strong>：子元素的放大比例，默认为 0。放大时所占用的空间是剩余空间</p>
</li>
<li><p><strong>flex-shrink</strong>：子元素的缩小比例，默认为 1，负值无效</p>
</li>
<li><p><strong>flex-basis</strong>：在分配多余空间时，子元素占父元素的主轴空间。默认值为 auto。可以设置为和宽度高度一样的值，则将占据固定的空间。</p>
</li>
<li><p><strong>flex</strong>：flex-grow、flex-shrink、flex-basis 属性的简写。默认值为 <code>0 1 auto</code></p>
</li>
<li><p><strong>align-self</strong>：单个子元素在交叉轴上的对其方式，值和 align-items 的值一致，还有一个 auto，默认继承父元素的 align-items 的值，如果没有父元素，则为 stretch。</p>
</li>
</ol>
<h2 id="6-grid-布局"><a href="#6-grid-布局" class="headerlink" title="6. grid 布局"></a>6. grid 布局</h2><p>默认情况下，父元素都是块级元素（grid），但也可以设为行内元素（inline-grid）。</p>
<blockquote>
<p>注意，设为网格布局以后，子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p>
</blockquote>
<p><strong>父元素属性</strong>：</p>
<ol>
<li><p><strong>grid-template-columns、grid-template-rows</strong>：分别为：定义每一列的列宽、定义每一行的行高</p>
<ul>
<li><p>repeat()：避免重复写同样的值，可以使用repeat 函数，定义重复的值</p>
<p>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p>
<p><code>grid-template-columns: repeat(3, 33.33%);</code>  &#x2F;&#x2F; 生成 3 列，均为 33%宽度</p>
<p><code>grid-template-columns: repeat(2, 100px 20px 80px);</code>  可以生成 6 列，</p>
</li>
<li><p><strong>auto-fill</strong>：自动填充，尽可能多的容纳单元格。</p>
<p> <code>grid-template-columns: repeat(auto-fill, 100px);</code> &#x2F;&#x2F; 每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p>
</li>
<li><p><strong>fr关键字</strong>：方便表示比例关系，如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p>
</li>
<li><p>**minmax()**：函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<p><code>grid-template-columns: 1fr 1fr minmax(100px, 1fr);</code> &#x3D;&gt; <code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p>
</li>
<li><p><strong>auto 关键字</strong>：<code>auto</code>关键字表示由浏览器自己决定长度。</p>
</li>
</ul>
</li>
<li><p><strong>grid-row-gap、grid-column-gap</strong>：分别表示设置行与行的间隔（行间距）、设置列与列的间隔（列间距）</p>
</li>
<li><p><strong>grid-gap</strong>：<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式</p>
<blockquote>
<p>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p>
</blockquote>
</li>
<li><p><strong>grid-template-areas</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line"><span class="attribute">grid-template-areas</span>: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                     <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                     <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p>
<p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p>
</blockquote>
</li>
<li><p><strong>grid-auto-flow</strong>：容器的子元素会按照顺序，自动放置在每一个网格。</p>
<p>默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行。</p>
<ul>
<li><p><code>row</code> ：”先行后列”</p>
</li>
<li><p><code>column</code>，变成”先列后行”</p>
</li>
<li><p><code>row dense</code>：表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p>
</li>
<li><p><code>column dense</code>：表示”先列后行”，并且尽量填满空格。</p>
</li>
</ul>
</li>
<li><p><strong>justify-items、align-items</strong>：分别表示：设置单元格内容的水平位置（左中右）、设置单元格内容的垂直位置（上中下）。</p>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
</li>
<li><p><strong>place-items</strong>：<code>justify-items</code> 和 <code>align-items</code>的简写：<code>place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></p>
</li>
<li><p><strong>justify-content、align-content</strong>：分别表示：整个内容区域在容器里面的水平位置（左中右）、整个内容区域的垂直位置（上中下）。</p>
<ul>
<li><p>start - 对齐容器的起始边框。</p>
</li>
<li><p>end - 对齐容器的结束边框。</p>
</li>
<li><p>center - 容器内部居中。</p>
</li>
<li><p>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</p>
</li>
<li><p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</p>
</li>
<li><p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</p>
</li>
<li><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p>
</li>
</ul>
</li>
<li><p><strong>place-content</strong>：<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式</p>
<p><code>place-content: &lt;align-content&gt; &lt;justify-content&gt;</code></p>
</li>
<li><p><strong>grid-auto-columns、grid-auto-rows</strong>：<code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
</li>
</ol>
<p><strong>子元素属性：</strong></p>
<ol>
<li><p>grid-column-start、grid-column-end、grid-row-start、grid-row-end</p>
<ul>
<li><p><code>grid-column-start</code>属性：左边框所在的垂直网格线</p>
</li>
<li><p><code>grid-column-end</code>属性：右边框所在的垂直网格线</p>
</li>
<li><p><code>grid-row-start</code>属性：上边框所在的水平网格线</p>
</li>
<li><p><code>grid-row-end</code>属性：下边框所在的水平网格线</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123; <span class="comment">/*1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。*/</span> </span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
</li>
<li><p><strong>grid-column、grid-row</strong>：<code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>grid-area</strong>：指定项目放在哪一个区域。</p>
</li>
<li><p><strong>justify-self、align-self</strong></p>
<p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p>
<p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
</li>
</ol>
<p>这玩意属性太多了，还是单独整理成一个文档吧。</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 - 阮一峰</a></p>
<h2 id="7-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#7-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="7. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>7. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h2><p><a target="_blank" rel="noopener" href="https://github.com/haibolian/code-grocery/blob/main/%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html">居中布局方式汇总</a></p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-JavaScript-都有哪些数据类型"><a href="#1-JavaScript-都有哪些数据类型" class="headerlink" title="1. JavaScript 都有哪些数据类型"></a>1. JavaScript 都有哪些数据类型</h2><p>​	基本数据类型: <code>undefined</code> <code>null</code> <code>boolean</code> <code>string</code> <code>number</code> <code>symbol</code> <code>bigInt</code></p>
<p>​	引用数据类型: <code>object</code></p>
<p>​	区别: 基本数据类型存储在栈内存中，按值存取; 引用数据类型存储在堆内存中， 按引用存取。</p>
<h2 id="2-普通函数和箭头函数的区别"><a href="#2-普通函数和箭头函数的区别" class="headerlink" title="2. 普通函数和箭头函数的区别"></a>2. 普通函数和箭头函数的区别</h2><ol>
<li><p>原型，箭头函数没有原型，原型是 <code>undefined</code></p>
</li>
<li><p>箭头函数没有 <code>arguments</code></p>
</li>
<li><p><code>this</code> 箭头函数的 this 是箭头函数所处环境的 this；普通函数中，this 的值取决于函数如何被调用的。</p>
</li>
<li><p>call、apply、bind 方法都改变不了箭头函数的指向， 第一个参数会被忽略</p>
</li>
<li><p>箭头函数不能用作构造器，不能和 new 一起使用，因为：</p>
<ol>
<li>箭头函数没有自己的 this</li>
<li>没有 prototype 属性，而在 new 执行时需要将构造函数的 prototype 重新赋值给 _<em>proto</em>_</li>
</ol>
</li>
<li><p>yield 关键字不能在箭头函数中使用（除非嵌套在允许使用的函数内），因此 ，箭头函数不能用作生成器</p>
</li>
<li><p>返回值：箭头函数不加花括号（即箭头函数简写函数）时，默认返回函数体里面的内容；加花括号时，需要明确指定 return</p>
<blockquote>
<p>箭头函数简写时，直接返回一个对象字面量是行不通的，如果不想加花括号，又想使用简写函数返回，需要用括号把对象字面量包裹起来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt; &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;  <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt; (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;) <span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="3-reduce-用法及实现"><a href="#3-reduce-用法及实现" class="headerlink" title="3. reduce 用法及实现"></a>3. reduce 用法及实现</h2><p><strong>用法：</strong></p>
<ol>
<li>数组累加</li>
<li>利用 Math.max 获取数组最大值</li>
<li>数组去重</li>
<li>利用 <code>concat</code> 实现数组扁平化</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7011096419985522701">参考链接</a></p>
<p><strong>实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> areduce = <span class="keyword">function</span> (<span class="params">func, initValue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;a error param in areduce&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> iStartIndex = initValue !== <span class="literal">undefined</span> ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> iStartValue = initValue !== <span class="literal">undefined</span> ? initValue : <span class="variable language_">this</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> lastValue</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = iStartIndex; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    lastValue = <span class="title function_">func</span>(lastValue ?? iStartValue, <span class="variable language_">this</span>[i], i, <span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = areduce.<span class="title function_">call</span>(arr, <span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next, <span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>



<h2 id="4-jQuery和vue什么区别"><a href="#4-jQuery和vue什么区别" class="headerlink" title="4. jQuery和vue什么区别"></a>4. jQuery和vue什么区别</h2><p>vue 的核心思想是数据驱动，视图是由数据驱动产生。对视图的修改，不会直接操作 DOM， 而是通过数据修改。而 jQuery 是直接操作 DOM。vue 简化了操作 DOM 的代码量，只关系业务逻辑。</p>
<ul>
<li>vue 数据驱动</li>
<li>jq 操作 dom 元素</li>
<li>vue 简单或很少使用 dom</li>
<li>vue 渲染优雅，代码易维护</li>
</ul>
<p>那么为什么操作 DOM 会影响性能呢？</p>
<h2 id="5-为什么操作-DOM-会影响性能"><a href="#5-为什么操作-DOM-会影响性能" class="headerlink" title="5. 为什么操作 DOM 会影响性能"></a>5. 为什么操作 DOM 会影响性能</h2><p>在浏览器中，DOM 和 ES 是分离的，是两种东西。</p>
<p> 正因为二者相互独立，所以每次链接、每次访问DOM都会消耗性能 。</p>
<p>在此基础上，因为修改DOM会导致浏览器重新计算页面的几何变化、引发浏览器模板引擎的重排和重绘，进而更加消耗性能。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/padding1015/p/11405788.html">参考链接</a></p>
<h2 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6. 事件循环"></a>6. 事件循环</h2><p>js 是一门单线程语言，可以使用事件循环实现单线程非阻塞</p>
<p>在 js 中，所有任务分为同步任务和异步任务，同步任务先进入主线程执行，执行完毕后再执行异步任务。但将任务划分为同步任务和异步任务不过准确，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>理想的结果是 <code> 1 -&gt; newPromise -&gt; 3 -&gt; 2 -&gt;then</code></p>
<p>但实际结果是 <code> 1 -&gt; newPromise -&gt; 3 -&gt; then -&gt; 2</code></p>
<p>原因是异步任务还可以细分为 宏任务 和 微任务</p>
<p><strong>宏任务：</strong></p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout&#x2F;setInterval</li>
<li>UI rendering&#x2F;UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I&#x2F;O（Node.js）</li>
</ul>
<p><strong>微任务：一个需要异步执行的函数，执行时机是在主函数结束之后，当前宏任务结束之前， 也可以理解成当前宏任务结束之后，下一个宏任务开始之前</strong></p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<p><strong>运行机制</strong></p>
<p>宏任务队列：<code>MacroTask Queue</code></p>
<p>微任务队列：<code>MicroTask Queue</code></p>
<ul>
<li>执行一个宏任务（script 同步代码也是一个宏任务），如果遇到微任务，将其添加到 <code>MicroTask Queue</code>中</li>
<li>当前宏任务执行完毕，查找微任务队列中是否含有待执行的微任务，如果存在微任务，需将当前微任务队列的所有微任务（包括当前宏任务执行过程中遇到的微任务）执行完毕才能进行下一个宏任务</li>
<li>当前宏任务和微任务执行完毕，开始检查渲染，然后GUI线程接管渲染，渲染页面</li>
<li>页面渲染完毕，取出下一个宏任务，继续执行。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 被读取到主线程栈中的代码一定是<strong>已经执行完成</strong>的异步代码。</p>
<p>如果一个宏任务是异步任务，只有当此异步任务执行完成后，才会将其回调函数推送到任务队列中，供主线程栈读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>上例代码执行结果为 <code>1 -&gt; 2</code></p>
<p>因为 1 先执行完毕，推入任务队列中；2 在 1 之后执行完毕</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78113300">js中的宏任务与微任务</a></p>
<p><a target="_blank" rel="noopener" href="https://interview.codespring.top/JavaScript/event_loop.html">事件循环</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3f675a55417b">EventLoop和任务队列(微任务和宏任务)</a></p>
<h2 id="7-显示转换、隐式转换"><a href="#7-显示转换、隐式转换" class="headerlink" title="7. 显示转换、隐式转换"></a>7. 显示转换、隐式转换</h2><h2 id="8-防抖"><a href="#8-防抖" class="headerlink" title="8. 防抖"></a>8. 防抖</h2><p>防抖就类似回城，打断就得重新回。</p>
<ul>
<li>立即执行版</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123; </span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    !timer &amp;&amp; fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非立即执行版</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终版</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time, immediate</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    immediate &amp;&amp; !timer &amp;&amp; fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      immediate ? timer = <span class="literal">null</span> : fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, time) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-节流"><a href="#9-节流" class="headerlink" title="9. 节流"></a>9. 节流</h2><p>节流就类似技能需要冷却时间到了才能用。</p>
<ul>
<li>定时器版</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer) <span class="keyword">return</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间戳版</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> ( now - prev &gt; time) &#123;</span><br><span class="line">      <span class="title function_">fn</span>()</span><br><span class="line">      prev = now</span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-深浅拷贝"><a href="#10-深浅拷贝" class="headerlink" title="10. 深浅拷贝"></a>10. 深浅拷贝</h2><ul>
<li>浅拷贝<ol>
<li>等号赋值</li>
<li><code>Object.assign()</code></li>
<li>array 的一些方法</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cloneshallow</span>(<span class="params">target</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cloneTarget) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        cloneTarget[key] = target[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>深拷贝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对对象循环使用 WeakMap ， 因为 WeakMap 只接受object作为键名，其中的引用类型都是弱引用类型，且不计入垃圾回收机制</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clonedeep</span>(<span class="params">target, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>( target &amp;&amp; target.<span class="property">constructor</span> === <span class="title class_">Date</span> ) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(target)</span><br><span class="line">  <span class="keyword">if</span>( target &amp;&amp; target.<span class="property">constructor</span> === <span class="title class_">RegExp</span> ) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(target)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hash.<span class="title function_">has</span>(target)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">let</span> allDescp = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(target)</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? </span><br><span class="line">      [] : <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(target),allDescp)</span><br><span class="line">    hash.<span class="title function_">set</span>(target,cloneTarget)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)) &#123;</span><br><span class="line">      cloneTarget[key] = <span class="title function_">clonedeep</span>(target[key],hash )</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-原型和原型链"><a href="#11-原型和原型链" class="headerlink" title="11. 原型和原型链"></a>11. 原型和原型链</h2><p><strong>原型</strong>： 每一个函数都会默认有一个 prototype 属性，指向原型对象，原型对象默认只会获得 constructor 属性，这个 constructor 指向的是这个构造函数。通过构造函数 new 出来的实例都会有一个 [[prototype]]，指向构造函数的原型对象。脚本没有访问 [[prototype]] 的方式，但浏览器，例如 chrome，safari，火狐，会在每个实例上暴露一个 _<em>proto</em>_ ,用于指向原型，也就是构造函数的原型对象。</p>
<p><code>isPrototypeOf</code>，判断是否是某个实例的原型</p>
<p><code>Object.getPrototypeOf</code>， 获取某个实例的原型</p>
<p><code>Object.setPrototypeOf</code>，为实例设置原型</p>
<p><strong>原型链：</strong></p>
<p>在读取实例上的属性时，首先会在实例本身上面查找，如果没有找到，就会去找该实例的 <code>__proto__</code> ，也就是构造函数的 prototype。</p>
<p>如果实例的 <code>__proto__</code> 上没有， 这个 <code>__proto__</code> 也是某个类型的实例，于是去找 <code>__proto__</code> 的 <code>__proto__</code>，直到 Object 的 prototype，也就是 null， 这就是原型链。</p>
<h2 id="12-for…in-和-for…of"><a href="#12-for…in-和-for…of" class="headerlink" title="12. for…in 和 for…of"></a>12. for…in 和 for…of</h2><ul>
<li><p><strong><code>for...in</code></strong></p>
<p><code>for...in</code> 会遍历自身的可枚举属性，以及原型链中的可枚举属性。如果想只遍历自身属性，可以使用 <code>hasOwnProperty</code> 判断。</p>
<p><code>for...in</code> 一般适用于遍历对象，遍历数组时不一定按照次序遍历。</p>
</li>
<li><p><strong><code>for of</code></strong></p>
<p><code>for...of</code>是 ES6 新引进的语法，用于遍历可迭代对象。适用于遍历数组。遍历对象报错。</p>
</li>
</ul>
<h2 id="13-创建对象的各种方式"><a href="#13-创建对象的各种方式" class="headerlink" title="13. 创建对象的各种方式"></a>13. 创建对象的各种方式</h2><ul>
<li><p><strong>工厂模式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o.<span class="property">name</span> = name;</span><br><span class="line">  o.<span class="property">age</span> = age;</span><br><span class="line">  o.<span class="property">job</span> = job;</span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">	<span class="keyword">return</span> o; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数模式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;; &#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="new-操作符干了什么"><a href="#new-操作符干了什么" class="headerlink" title="new 操作符干了什么?"></a>new 操作符干了什么?</h3><ol>
<li><p>在内存中创建一个新对象。</p>
</li>
<li><p>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</p>
</li>
<li><p>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</p>
</li>
<li><p>执行构造函数内部的代码（给新对象添加属性）。</p>
</li>
<li><p>如果构造函数返回非空对象，则返回该对象;否则，返回刚创建的新对象。</p>
<p>构造函数的缺点是，定义的方法都会在每个实例上都定义一遍。各个实例虽然函数同名，但并不是同一个 Funtion 实例。解决方法是在内部定义方法时指向外部的同一个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newFunc</span>(<span class="params">constructer</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> restArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  instance.<span class="property">__proto__</span> = constructer.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> result = constructer.<span class="title function_">apply</span>(instance, restArgs)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>原型模式</strong></li>
</ul>
<h2 id="14-和-的区别"><a href="#14-和-的区别" class="headerlink" title="14. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别"></a>14. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别</h2><ul>
<li><p><strong>&#x3D;&#x3D;</strong> </p>
<p>&#x3D;&#x3D; 在比较之前，会先进行类型转换，直到类型相同，在确定操作数是否相等。遵循以下规则：</p>
<p>1、如果两个值类型相同，进行 &#x3D;&#x3D;&#x3D; 比较。 </p>
<p>2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： </p>
<p>  a、如果一个是null、一个是undefined，那么[相等]。 </p>
<p>  b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 </p>
<p>  c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 </p>
<p>  d、如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString。</p>
<p>  e、任何其他组合，都不相等。</p>
</li>
<li><p>&#x3D;&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;&#x3D; 只有在不转换类型的前提下相等才返回 true，类型必须相同，值也必须相同</p>
</li>
</ul>
<h2 id="15"><a href="#15" class="headerlink" title="15."></a>15.</h2><h2 id="16-js-中字符串常用方法"><a href="#16-js-中字符串常用方法" class="headerlink" title="16. js 中字符串常用方法"></a>16. js 中字符串常用方法</h2><ul>
<li><code>indexOf</code> ：查询字符串中是否含有某个内容 ， 返回字符串中的指定位置，未找到返回 -1</li>
<li><code>concat</code>： 链接字符串，返回连接后的字符串，不影响原来的字符串</li>
<li><code>split</code>：将字符串按某个字符拆分成一个数组，返回这个数组</li>
<li><code>toUpperCase</code>：转换成大写，返回它</li>
<li><code>toLowerCase</code>：转换成小写，返回它</li>
<li><code>trim</code>: 去掉前后空格</li>
</ul>
<h2 id="17-数组常用方法"><a href="#17-数组常用方法" class="headerlink" title="17. 数组常用方法"></a>17. 数组常用方法</h2><ul>
<li><p><code>forEach</code> 遍历数组，传一个回调函数，第一个和第二个参数分别是成员和索引</p>
</li>
<li><p><code>map</code> 遍历数组，传一个回调函数，第一个和第二个参数分别是成员和索引，返回由回调函数的返回值组成的数组。</p>
</li>
<li><p><code>find</code> 遍历数组，查询某个元素，传一个回调函数，第一个和第二个参数分别是成员和索引，当回调函数返回值为 true 时，查询停止，并且返回这个当前满足条件的成员</p>
</li>
<li><p><code>findIndex</code> 用法同 find，返回 find 中这个满足条件的成员的索引</p>
</li>
<li><p><code>some</code> 遍历数组，回调函数用法一样，当回调函数返回第一个 true 时，停止遍历，并且返回 true</p>
</li>
<li><p><code>every</code> 遍历数组，回调函数用法一样，只有当回调函数都返回 true，every 函数才会返回 true ，否则返回 false</p>
</li>
<li><p><code>filter</code> </p>
</li>
<li><p><code>includes</code> 传入两个参数，要搜索的值和开始搜索的位置的索引，查询数组中是否包含这个成员。includes 采用的是三等运算符（&#x3D;&#x3D;&#x3D;），但和 &#x3D;&#x3D;&#x3D; 的区别是对 NaN 的处理不同，&#x3D;&#x3D;&#x3D; 中 NaN &#x3D;&#x3D;&#x3D; NaN 是 false， 但 includes 是可以搜索到的。</p>
</li>
<li><p><code>reduce</code> 接受两个参数：</p>
<p>第一个参数是一个回调函数，这个回调函数有三个参数，prev、current、index ，表示前一个值、当前值、索引</p>
<p>reduce 的第二个参数可选，是回调函数的前一个值</p>
<p>如果传了第二个参数，那么将从数组的第一个成员开始循环，索引从 0 开始；如果不传，那么将从第二个成员开始循环，索引从 1 开始。</p>
</li>
<li><p><code>reduceRight</code> 和 reduce 用法一样，从后往前循环。</p>
</li>
<li><p><code>join</code> 接受一个参数，将数组以这个参数分隔连成一个字符串</p>
</li>
<li><p><code>slice</code> 截取数组，接受两个参数，startIndex、endIndex，从 startIndex 开始截取，到 endIndex 结束，包含 startIndex，不包含 endIndex，返回这一区间内的所有成员</p>
</li>
<li><p><code>splice</code> 删除或替换数组指定位置的成员，会修改原数组，接受 n 个参数，第一个参数是开始替换的位置索引，第二个参数是替换的个数，第三个到第 n 个参数是要填充的成员（可选），若没有要填充的成员，则表示删除，返回被替换掉的区间的所有成员组成的数组。</p>
</li>
<li><p><code>indexOf</code> 查询数组中是否包含指定的成员，返回索引。使用 &#x3D;&#x3D;&#x3D; 比较。和 includes 不同的是，indexOf 比较时，NaN &#x3D;&#x3D;&#x3D; NaN 为 false，includes 为 true</p>
</li>
<li><p><code>fill</code> 填充数组 (value [, start, [ end ] ])  </p>
</li>
<li><p><code>sort</code> <strong>排序，看看资料吧</strong>。</p>
</li>
<li><p><code>reverse</code> 数组反转，影响原数组</p>
</li>
<li><p><code>push</code> 向数组尾部增加成员</p>
</li>
<li><p><code>unshift</code> 将一个或多个元素添加到数组的<strong>开头</strong>，并返回该数组的<strong>新长度(该</strong>方法修改原有数组**)**。 </p>
</li>
<li><p><code>shift</code> 从数组中删除第一个成员，并返回该成员</p>
</li>
<li><p><code>pop</code>  从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</p>
</li>
</ul>
<h2 id="18-JavaScript中执行上下文和执行栈是什么"><a href="#18-JavaScript中执行上下文和执行栈是什么" class="headerlink" title="18. JavaScript中执行上下文和执行栈是什么"></a>18. JavaScript中执行上下文和执行栈是什么</h2><p>全局执行上下文和函数执行上下文</p>
<ol>
<li><p>程序启动，执行全局代码，创建全局上下文，全局上下文被压入执行上下文栈。</p>
</li>
<li><p>全局上下文初始化：VO（变量对象）、scope（作用域）、this</p>
</li>
<li><p>全局上下文初始化的同时，函数被创建，则将全局上下文的作用域链保存到函数的<code>[[scope]]</code>属性中</p>
</li>
<li><p>函数执行，创建函数执行上下文，函数执行上下文被压入执行上下文栈</p>
</li>
<li><p>初始化函数执行上下文，</p>
</li>
</ol>
<p>  （1） 复制函数的 <code>[[scope]]</code>  属性创建作用域链 </p>
<p>  （2） 用<code>arguments</code>创建活动对象</p>
<p>  （3） 初始化活动对象，加入形参，函数声明，变量声明。</p>
<p>  （4） 将活动对象压入 函数的作用域链的顶端</p>
<ol start="6">
<li>函数执行完毕，函数执行上下文从执行上下文栈中弹出</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/8">[JavaScript深入之执行上下文]</a></p>
<h2 id="19-谈谈你对作用域和作用域链的理解"><a href="#19-谈谈你对作用域和作用域链的理解" class="headerlink" title="19. 谈谈你对作用域和作用域链的理解"></a>19. 谈谈你对作用域和作用域链的理解</h2><ol>
<li><p><strong>作用域</strong></p>
<p>作用域是变量的适用范围，作用域决定了代码区块中变量的可见性。比方说函数作用域，函数内所有定义的变量都只能在函数内部使用，在函数外无法</p>
<p>问。</p>
<p>作用域主要有静态作用域（也就是词法作用域）和动态作用域</p>
<p>js采用的是静态作用域，特点是作用域在函数定义的时候就已经确定了。动态作用域是在函数执行时才确定作用域。</p>
</li>
<li><p><strong>作用域链</strong></p>
<p>当查找变量的时候，会先从当前执行上下文的变量对象中查找，如果没找到，就会去父级（词法层面的父级，并非谁调用的，谁就是父，而是看函数定义时</p>
<p>的父级）执行下上文中去查找，一直到全局执行上下文中，直到找到为止。这样由多个执行上下文变量对象构成的链表，就叫做作用域链。</p>
<p>函数有一个<code>[[scope]]</code>属性，里面放着父级的作用域链，函数执行时，初始化函数的执行上下文，创建活动对象，将活动对象添加到<code>[[scope]]</code>的最前面，那</p>
<p>么，那么这个函数的作用域链就生成了。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a></p>
<h2 id="20-变量对象"><a href="#20-变量对象" class="headerlink" title="20. 变量对象"></a>20. 变量对象</h2><p>变量对象在执行上下文中，里面是变量和函数的声明。</p>
<p>不同的执行上下文它的变量也不同，有全局执行上下文中的变量对象和函数执行上下文中的变量。</p>
<p>全局执行上下文的变量对象在代码的任何地方都能访问到，因为按照作用域链会一直找到全局执行上下文。</p>
<p>函数执行上下文的变量对象是在进入函数执行上下文时生成的，此时函数还未执行，初始化活动对象（活动对象和变量对象是一个东西）包括形参，变量声明、</p>
<p>函数声明，变量声明和函数声明的值此时为<code>undefined</code>。当函数执行的时候，修改活动对象的值，为变量声明和函数声明赋值。</p>
<h2 id="21-说说你对闭包的理解，什么场景下使用闭包"><a href="#21-说说你对闭包的理解，什么场景下使用闭包" class="headerlink" title="21. 说说你对闭包的理解，什么场景下使用闭包"></a>21. 说说你对闭包的理解，什么场景下使用闭包</h2><p>闭包是指那些能够访问自由变量的函数。</p>
<p>自由变量是指在函数中使用，但既不是函数的参数也不是函数的局部变量。</p>
<p>这个是<strong>理论角度</strong>的闭包。</p>
<p>在<strong>实践角度</strong>，满足这两个条件才算闭包：</p>
<ol>
<li><p>即使创建它的上下文已被销毁，但这个函数依然存在。</p>
</li>
<li><p>这个函数在代码中使用了自由变量。</p>
</li>
</ol>
<p>闭包中之所以能够依然访问到自由变量，是因为<code>[[scope]]</code>属性。</p>
<p>在进入父函数的执行上下文中，会初始化作用域链，将父函数的作用域链（词法层面上的父级们的AO&#x2F;VO）保存到子函数的<code>[[scope]]</code>属性中，即使父级函数执</p>
<p>行上下文销毁了，js依然可以让父级函数的执行上下文的活跃对象（AO）活在内存中。</p>
<p>就算把子函数返回出去，在子函数进入执行上下文时，会通过活跃对象（AO），和<code>[[scope]]</code>维护一个新的作用域链，将活跃对象（AO）放到最前面。所以子函</p>
<p>数依然可以从作用域链中找到那个自由变量，从而实现了闭包。 </p>
<h2 id="20-谈谈你对-this-的理解"><a href="#20-谈谈你对-this-的理解" class="headerlink" title="20. 谈谈你对 this 的理解"></a>20. 谈谈你对 this 的理解</h2><ul>
<li><p>对于普通函数，this 的指向由函数的执行环境决定。包括全局环境，对象环境，构造函数环境，事件对象。</p>
<ul>
<li>在全局环境下，this 指向的是全局对象</li>
<li>在对象环境下，this 指向的是调用该函数的对象</li>
<li>在构造函数环境下，this 指向的是实例对象</li>
<li>在事件对象中，this 指向触发事件的 DOM 元素本身</li>
</ul>
<p>通过 call、apply、bind 可以改变函数 this 的指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oo1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fnn</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fnn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oo1.<span class="title function_">fn</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>单独的函数调用指向 <code>window</code></strong> 这一点还没很理解</li>
</ul>
</li>
<li><p>对于箭头函数的 this，是在箭头函数定义时就决定了的，指向的是定义时所在的作用域指向的对象</p>
<p>其实箭头函数本身没有 this，如果使用 this 的话，this 指向的是上一级非箭头函数的 this</p>
<p>另外，箭头函数不能通过 new 实例化对象。</p>
</li>
</ul>
<h2 id="21-js-中的事件模型"><a href="#21-js-中的事件模型" class="headerlink" title="21. js 中的事件模型"></a>21. js 中的事件模型</h2><p>js中的事件模型有 DOM0级事件模型，DOM2级事件模型，IE事件模型</p>
<p><strong>DOM0级事件模型</strong>：是一种原始的事件模型</p>
<p>​	<strong>优点</strong>：所有浏览器都兼容</p>
<p>​	<strong>缺点</strong>：相同事件的监听函数只能绑定一个，后绑定的会覆盖之前绑定的；没有事件冒泡、捕获</p>
<p><strong>DOM2级事件模型</strong>：标准事件模型，事件发生包含三个过程，事件捕获阶段、事件目标阶段、事件冒泡阶段。</p>
<p>​	<strong>事件捕获阶段：</strong> 当某个元素出发事件，先从顶层 document 发出一个事件流，随着 DOM 树的节点向目标元素	流去，直到到达目标节点。</p>
<p>​	<strong>事件目标阶段：</strong> 到达事件目标，执行事件绑定的函数</p>
<p>​	<strong>事件冒泡阶段：</strong> 从目标函数往顶层元素传播</p>
<p>​	事件绑定方法：<code>addEventListener(事件类型，事件处理函数，true/false)</code></p>
<p>​	移除监听：<code>removeEventListener(事件类型，事件处理函数，true / false)</code></p>
<p>​	<em>第三个参数表示事件在何时被触发，在过程中的节点，如果设置了同类型事件并设置为 true，则表示该节点的事件在捕获阶段被触发； 为 false 则表示在冒泡阶段被触发，默认为 false</em></p>
<p>​	<strong>阻止捕获、冒泡：</strong> 如果不需要触发捕获或冒泡机制的话，可以阻止</p>
<p>​	<code>e.preventDefault()</code> 表示阻止捕获，某个节点阻止捕获并不影响事件流往下传播</p>
<p>​	<code>e.stopPropagation()</code> 表示阻止冒泡，某个节点阻止冒泡后将不会在往上传播</p>
<p><strong>IE事件模型</strong></p>
<p>IE事件模型有两个过程，事件处理阶段和事件冒泡阶段，这两个阶段和DOM2级事件类似。</p>
<h2 id="22-typeof-和-instanceof-区别"><a href="#22-typeof-和-instanceof-区别" class="headerlink" title="22. typeof 和 instanceof 区别"></a>22. typeof 和 instanceof 区别</h2><p><code>typeof</code> 只能判断基本类型，不能区分引用类型，如object 、array、null、它们都返回 object</p>
<p>instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，但string、number、boolean 基本数据类型不能判断</p>
<h2 id="23-bind、call、apply-区别？"><a href="#23-bind、call、apply-区别？" class="headerlink" title="23. bind、call、apply 区别？"></a>23. bind、call、apply 区别？</h2><ul>
<li><code>call</code>：用一个指定的 this 值和一个或多个参数来调用一个函数。</li>
<li><code>apply</code>：用一个指定的 this 值和一个参数组成的数组来调用一个函数。</li>
<li><code>bind</code> ：创建一个新的函数，在bind被调用时，这个新函数的 this 被 bind 的第一个参数指定，其余参数作为新函数的参数供调用时使用。</li>
</ul>
<h2 id="24-手写-bind、call、apply"><a href="#24-手写-bind、call、apply" class="headerlink" title="24. 手写 bind、call、apply"></a>24. 手写 bind、call、apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call2</span> = <span class="keyword">function</span> (<span class="params">content</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = content || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> args = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; index++) &#123;</span><br><span class="line">    args.<span class="title function_">push</span>(<span class="string">&#x27;arguments[&#x27;</span> + index + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">aSymbol</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> symb = <span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">if</span>(ctx.<span class="title function_">hasOwnProperty</span>(symb))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">aSymbol</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symb</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> symb = <span class="title function_">aSymbol</span>(content)</span><br><span class="line">  content[symb] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;content[symb](&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  <span class="keyword">delete</span> content[symb]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply2</span> = <span class="keyword">function</span> (<span class="params">content, paramsArr</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = content || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> args = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">aSymbol</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> symb = <span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">if</span>(ctx.<span class="title function_">hasOwnProperty</span>(symb))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">aSymbol</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symb</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> symb = <span class="title function_">aSymbol</span>(content)</span><br><span class="line">  content[symb] = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span>(!paramsArr)&#123;</span><br><span class="line">    result = content[symb]()</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; paramsArr.<span class="property">length</span>; index++) &#123;</span><br><span class="line">      args.<span class="title function_">push</span>(<span class="string">&#x27;paramsArr[&#x27;</span> + index + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">&#x27;content[symb](&#x27;</span> + args.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> content[symb]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind2</span> = <span class="keyword">function</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Function.prototype.bind2 - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> originFn = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> bindParams = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> cb = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">// 当 cb 作为构造函数时，this指向的应该是实例，而不是ctx</span></span><br><span class="line">    originFn.<span class="title function_">apply</span>( <span class="variable language_">this</span> <span class="keyword">instanceof</span> cb ? <span class="variable language_">this</span> : ctx, bindParams.<span class="title function_">concat</span>(args));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  如果直接赋值，那么在外面修改 cb.prototype 也会影响到 this.prototype，可以通过中间函数中转一下</span></span><br><span class="line">  <span class="comment">// cb.prototype = this.prototype</span></span><br><span class="line">  <span class="keyword">const</span> middleFn = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  middleFn.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  cb.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">middleFn</span>()</span><br><span class="line">  <span class="keyword">return</span> cb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-谈谈单点登录"><a href="#25-谈谈单点登录" class="headerlink" title="25. 谈谈单点登录"></a>25. 谈谈单点登录</h2><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="1-var、let、const-区别"><a href="#1-var、let、const-区别" class="headerlink" title="1. var、let、const 区别"></a>1. var、let、const 区别</h2><ol>
<li><p>变量提升</p>
<p>var 存在变量提升，let、const 不存在变量提升</p>
</li>
<li><p>暂时性死区</p>
<p>块级作用域内，js 引擎会注意出现在块后面的 let 声明，在这个 let 声明之前，不能以任何方式来引用声明的变量，这种在语法上就叫做<strong>暂时性死区</strong>。</p>
</li>
<li><p>重复声明</p>
<p>var 可以重复声明变量，但 let 和 const 在块级作用域内只能声明一次，其中 const 在声明时必须赋值且不能修改，let 声明后可修改</p>
</li>
</ol>
<h2 id="2-介绍下-Set-和-Map"><a href="#2-介绍下-Set-和-Map" class="headerlink" title="2. 介绍下 Set 和 Map"></a>2. 介绍下 Set 和 Map</h2><p><strong>Set</strong></p>
<ul>
<li><p>set 是一种新的数据结构，类似于数组，set 的成员都是唯一的，没有重复的值。</p>
</li>
<li><p>Set 函数接受一个数组或者具有iterable接口的其他数据结构作为参数，用来初始化</p>
</li>
<li><p>set 实例可以通过 add() 方法增加成员</p>
</li>
<li><p>Set 加入成员的时候，不会发生类型转换，Set 内部判断相等的方法类似于 精确相等运算符 &#x3D;&#x3D;&#x3D; ，不过和 &#x3D;&#x3D;&#x3D; 主要的区别是NaN， set 会认为 NaN 等于自身， &#x3D;&#x3D;&#x3D; 认为 NaN 不等于自身</p>
</li>
<li><p><strong>Set 实例的属性：</strong></p>
<ul>
<li><code>size</code>：set 实例的成员总数</li>
<li><code>constructor</code>： 构造函数</li>
</ul>
</li>
<li><p><strong>Set 实例的方法</strong></p>
<ul>
<li><code>add()</code>：向 set 实例中增加成员， 返回 set实例本身。</li>
<li><code>has()</code>：接受一个参数，判断该参数是否在 set 实例内，返回一个布尔值</li>
<li><code>delete()</code>：删除某个成员，返回一个布尔值，表示是否删除成功</li>
<li><code>clear()</code>： 清空所有成员，无返回值</li>
</ul>
</li>
<li><p>Set 遍历操作</p>
<ul>
<li><code>keys()</code>：  返回一个键名遍历器</li>
<li><code>values()</code>：返回一个键值遍历器</li>
<li><code>entries()</code>：返回一个键值对遍历器</li>
<li><code>forEach()</code>：无返回值，类似于数组forEach ， 接受第二个参数，绑定内部处理函数的 this 。</li>
</ul>
<p>由于set 没有键名，只有键值，所以 keys 和 values 一样，keys 返回的键名就是键值，entries 返回的键名和键值也是一样的</p>
</li>
</ul>
<p><strong>WeakSet</strong></p>
<ul>
<li><p>WeakSet 和 Set 类似，不过 WeakSet 的成员只能是对象，不能是其他类型的值。</p>
</li>
<li><p>WeakSet 中的对象都是弱引用，<strong>垃圾回收机制不考虑WeakSet 对该对象的引用</strong>。</p>
</li>
<li><p>WeakSet不可遍历。因为 WeakSet 内部有多少成员，取决于垃圾回收机制有没有执行，执行前后很可能不一样。</p>
</li>
<li><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p>
</li>
<li><p>WeakSet 方法</p>
<ul>
<li>add()</li>
<li>delete()</li>
<li>has()</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>垃圾回收机制</strong>根据对象的可达性来判断回收，如果对象还能被访问到，就不会释放这块内存。当这个对象被用完之后，有时会忘记取消引用，导致内存无法释放，进而可能会造成内存泄漏。而 WeakSet 中的对象不计入垃圾回收机制，所以就不存在这个问题。只要WeakSet 在外部引用的这个对象在外部消失，那么WeakSet 里面的引用就会自动消失。</p>
</blockquote>
<p><strong>Map</strong></p>
<p>Map 和对象类似，都是键值对的集合，不过对象只能用字符串作为键，Map 可以用各种类型作为键。</p>
<ul>
<li><p>Map 可以接受一个用来表示键值对的数组初始化。任何具有 iterable 接口、且成员都是一个双元素的数组的数据结构，都可以作为构造函数参数。set 和 map也可用来生成新 Map</p>
</li>
<li><p>Map 的属性</p>
<ul>
<li><code>size</code>： 返回 Map 结构的成员总数。</li>
</ul>
</li>
<li><p>Map 的方法</p>
<ul>
<li><code>set(key, value)</code>： 返回整个 Map 结构。如果 key 已经存在，那么键值会被更新；否则新生成该键。</li>
<li><code>get(key)</code>： 返回<code>key</code> 对应的 <code>value</code>，如果没找到，返回 <code>undefined</code></li>
<li><code>has(key)</code>： 返回一个布尔，表示某个键是否存在 map 中</li>
<li><code>delete(key)</code>： 返回一个布尔，表示是否删除成功。</li>
<li><code>clear()</code>：清空 map，无返回值</li>
</ul>
</li>
<li><p>map 的遍历方法</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器。</li>
<li><code>values()</code>：返回键值的遍历器。</li>
<li><code>entries()</code>：返回所有成员的遍历器。</li>
<li><code>forEach()</code>：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
</li>
</ul>
<p><strong>WeakMap</strong></p>
<ul>
<li><p>WeakMap 与 Map 类似，主要区别有两点：</p>
<ul>
<li><p>WeakMap 的键只能是对象，null 除外。</p>
</li>
<li><p>WeakMap 的键名所指向的对象，不计入垃圾回收机制</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
</blockquote>
<ul>
<li>WeakMap 与 Map 在 API 上的区别主要是两个<ul>
<li>没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。</li>
<li>无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</li>
</ul>
</li>
</ul>
<h2 id="3-promise"><a href="#3-promise" class="headerlink" title="3. promise"></a>3. promise</h2><ol>
<li><strong>三种状态：</strong></li>
</ol>
<ul>
<li><strong>进行中（pending）</strong></li>
<li><strong>已成功（fulfilled）</strong></li>
<li><strong>已失败（rejected）</strong></li>
</ul>
<ol start="2">
<li><p><strong>一旦状态改变，就不会再变， 状态改变只能有两种情况，从 pending -&gt; fulfiled; pending -&gt; rejected。只要这两种情况发生，状态就凝固了，不会再变了，这时就称为 resolved（已定型）。</strong></p>
</li>
<li><p><code>promise.then</code> <code>resolved</code> 时的回调方法</p>
</li>
<li><p><code>promise.catch</code> <code>rejected</code> 时的回调方法</p>
</li>
<li><p><code>promise.finally</code> 不管状态最终如何，都会调用此回调，且此回调不接受任何参数</p>
</li>
<li><p><code>promise.all</code> 将多个 promise 实例，包装成一个 promise 实例。该方法接受一个数组或者一个 具有iterator 接口的数据作为参数，该数据的成员都必须为 promise 实例，如果不是，会先调用 promise.resovle 方法将参数转成实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2 ,p3])</span><br></pre></td></tr></table></figure>

<p>p 的状态取决于p1、p2、p3</p>
<p>当 p1、p2、p3 的状态都为 fulfilled 时，p 的状态才会为 fulfilled，此时，p1、p2、p3 的返回值组成的数组，传给 p 的回调函数。</p>
<p>当 p1、p2、p3 中有一个状态为 rejected 时，p 的状态就为 rejected，此时，第一个被 rejected 的返回值传递给 p 的回调函数</p>
<blockquote>
<p>注意，当第一个被 rejected 的 promise 实例自己定义了 catch 方法，并不会调用 promise.all 的 catch 方法。</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure>

<p>p1 先 resolved ，p2 rejected，并且执行 catch 方法，并返回一个新的 promise 实例，此时，p2 指向的是这个 catch 返回的新的 promise 实例，catch 执行完后，p2 也会 resolved ，因此 <code>Promise.all()</code> 方法参数里面的两个实例都会 <code>resolved</code> ，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<ol start="7">
<li><p>promise.race  </p>
<p><code>race： 速度竞赛/跑赢</code> </p>
<p>参数和 promise.all 一样，只要有一个状态先改变，promise.race 的状态就会变成这个第一个改变的 promise 的状态。</p>
</li>
<li><p>promise.allSettled</p>
</li>
<li><p>promise.any 参数和 promise.all 一样，只要有一个promise实例状态变为 fulfilled ，就会将该实例返回值，传给 promise.any 的回调函数；只有当所有的 promsie 实例都为 rejected 时，promise.all 状态才会变成 rejected</p>
</li>
<li><p>promise.resolve 将一个对象转成 Promise 对象</p>
<ul>
<li><p><strong>参数是 promise 实例</strong></p>
<p>原封不动的返回该 promise 实例</p>
</li>
<li><p><strong>thenable： 参数是一个含有 then 方法的对象</strong></p>
<p>将该对象转成 promise 对象，然后立即执行该对象的 then 方法</p>
</li>
<li><p><strong>参数是不具有<code>then</code>方法的对象，或根本就不是对象</strong></p>
<p>将该参数转为 promise 对象，状态为 resolved</p>
</li>
<li><p><strong>不带有任何参数</strong></p>
<p>直接返回一个resolved 状态的 promise 对象</p>
</li>
</ul>
</li>
</ol>
<h2 id="4-class"><a href="#4-class" class="headerlink" title="4. class"></a>4. class</h2><ul>
<li><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3></li>
<li><h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3></li>
<li><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>静态方法的 this</li>
<li>方法重名</li>
<li>可以继承</li>
</ul>
</li>
<li><h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3></li>
<li><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2></li>
<li><h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h3><p>判断方法</p>
</li>
<li><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3></li>
<li><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>super</p>
<p>子类在构造函数中必须调用一个 super方法，否则会报错。调用 super 方法会生成一个继承父类的this 对象，没有这一步就无法继承父类。</p>
<p><strong>ES5 的继承机制</strong>是，先创建一个子类的实例对象，再将原型指向父类的prototype，即“实例在前，继承在后”。</p>
<p><strong>ES6 的继承机制</strong>是先将父类的属性和方法添加到一个空对象中，再将该对象作为子类的实例。</p>
<ul>
<li><p>super 作为函数调用</p>
<p>super 作为函数调用只能在子类的构造函数中使用，在其他地方使用会报错。</p>
</li>
<li><p>super 作为对象使用</p>
<p>在<strong>普通方法</strong>中，super 指向父类的原型对象。无法获取父类实例属性和方法。调用父类方法时，方法内部的 this 指向子类的实例</p>
<p>在<strong>静态方法</strong>中，super 指向父类。调用父类方法时，方法内部的 this 指向当前子类，而不是子类实例。</p>
</li>
</ul>
</li>
<li><p>都有哪些会被继承？</p>
<p>除了私有属性和方法，其余的都会被继承。</p>
</li>
<li><p><code>Object.getPrototypeOf()</code>方法可以用来从子类上获取父类。</p>
</li>
</ul>
<p><em><u>先去回顾一下原型和原型链，在继续学习 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C__proto__%E5%B1%9E%E6%80%A7">类的 prototype 属性和__proto__属性</a></u></em></p>
</li>
</ul>
<p>	</p>
<h2 id="5-Proxy"><a href="#5-Proxy" class="headerlink" title="5. Proxy"></a>5. Proxy</h2><p>Proxy 代理的意思。</p>
<p>Proxy 接受两个参数，第一个参数是被代理的对象；第二个是在对该对象做各种操作时的一个配置对象。比如取值，赋值。</p>
<p>想要让配置对象生效，需要对生成的实例进行操作，不能对目标对象进行操作。</p>
<p><strong>Proxy 支持的拦截操作：</strong></p>
<blockquote>
<p><strong>target</strong>: 目标对象</p>
<p><strong>propKey</strong>：属性名</p>
<p><strong>receiver</strong>： proxy 实例本身</p>
</blockquote>
<ul>
<li><code>get(target, propKey, receiver)</code>：<code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，其中最后一个参数可选。</li>
<li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，返回一个布尔值</li>
<li><code>has(target, propKey)</code>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
</ul>
<p>一般只用到 get 和 set ，其他操作见<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/proxy">这里</a></p>
<p><strong>this 问题</strong>：</p>
<p>proxy 的目标对象中的 this 指向的是 proxy 实例，并非目标对象本身，如果想指向目标对象本身，需要在拦截配置参数中 <code>this</code> 绑定原始对象</p>
<h2 id="6-Iterator"><a href="#6-Iterator" class="headerlink" title="6. Iterator"></a>6. Iterator</h2><ol>
<li><p><strong>迭代器解决了什么问题</strong></p>
<p>js 原来的数据结构本来有数组和对象，到 ES6 又有了set 和 map ，那么就需要一个统一的接口机制，来处理不同的数据结构。迭代器就是这种机制，它是一个接口，为不同的数据结构提供统一的访问机制。任何数据结构只要遍历iterator接口，就可以完成遍历操作。</p>
</li>
<li><p><strong>Symbol.iterator 函数规则</strong></p>
<p>symbol.iterator是一个函数，它返回一个对象，这个对象有 next 方法。</p>
<p>next 方法返回一个对象，这个对象有 value 和done 属性，其中done 是个布尔，当遍历到最后一个元素时，done 为 true，代表结束。</p>
</li>
<li><p><strong>iterator 的遍历过程</strong></p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。</li>
<li>第一次调用 next 方法，指针对象指向数据结构的第一个成员</li>
<li>第二次调用 next 方法，指针对象指向数据结构的第二个成员</li>
<li>不断地调用 next 方法，直到指针对象指向数据结构的结束位置</li>
</ol>
</li>
<li><p><strong>默认含有Symbol.iterator的数据结构都有哪些</strong></p>
<ul>
<li>string</li>
<li>array</li>
<li>set</li>
<li>map</li>
<li><strong>函数的 arguments对象</strong></li>
<li><strong>nodelist 对象</strong></li>
</ul>
</li>
<li><p><strong>什么情况下会调用Iterator接口</strong></p>
<ul>
<li>使用 for…of 遍历数据时</li>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield</li>
</ul>
</li>
</ol>
<h2 id="7-Generator"><a href="#7-Generator" class="headerlink" title="7. Generator"></a>7. Generator</h2><ol>
<li><p><strong>什么是生成器函数</strong></p>
<p>在 function 关键字和函数名之间有一个星号，在函数体内部有 yield 表达式，这样就是一个生成器函数。</p>
<p>执行生成器函数返回一个遍历器对象，每执行一个遍历器对象的 next 方法会依次执行到每一个 yield 表达式</p>
</li>
<li><p><strong>yield表达式</strong></p>
<p>generator 函数返回带有 next 方法的遍历器对象。</p>
<p>next 方法执行时，遇到 yield 表达式，就会暂停后面的操作，并把 yield 后面紧跟着的表达式的值作为 value 返回。</p>
<p>再次调用 next，一直执行，直到遇见下一个 yield 表达式。</p>
<p>如果没有遇到新的 yield 表达式，直接执行到 return，将return 后面的表达式的值作为 value 返回，并且 done 为 true；如果没有return 语句，则返回的 value 为 undefined</p>
</li>
<li><p><strong>Generator 与 Iterator 的关系</strong></p>
<p>任意对象上的 Symbol.iterator 函数就是一个遍历器生成函数，而 generator 就是一个遍历器生成函数。</p>
<p>所以，可以直接将 generator 函数赋值给任意对象的 Symbol.iterator 属性。</p>
</li>
<li><p><strong>next方法的参数</strong></p>
<p>yield 表达式本身没有返回值，或者说只返回 undefined，next 方法可以传入一个参数，代表上一个 yield 表达式的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> y = <span class="number">2</span> + (<span class="keyword">yield</span> <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">yield</span> y * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">gen</span>()</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// 3</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// NaN</span></span><br><span class="line">a.<span class="title function_">next</span>(<span class="number">3</span>) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Generator 与 for…of 的关系</strong></p>
<p>for…of 可以自动循环 generator 返回的遍历器对象。不用依次调用 next 方法。</p>
</li>
<li><p><strong>Generator.prototype.throw()</strong></p>
</li>
<li><p><strong>Generator.prototype.return()</strong></p>
<p>generator 生成的遍历器对象可以执行 return 方法，用于终止遍历，该方法接受一个参数用于指定返回的值。</p>
</li>
<li><p><strong>yield</strong>*</p>
<p>在 generator 函数体内，调用另一个 generator 函数，需要在前者函数体内部，手动完成 generator 的遍历操作。ES6 提供 yield* 表达式，用于在 generator 函数体内执行另一个 generator 函数。</p>
</li>
<li></li>
</ol>
<h2 id="8-async"><a href="#8-async" class="headerlink" title="8. async"></a>8. async</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h2><p>​	vue2: <code>beforeCreate</code> -&gt; <code>created</code> -&gt; <code>beforeMount</code> -&gt; <code>mounted</code> -&gt; <code>beforeUpdate</code> -&gt; <code>updated</code> -&gt; <code>beforeDestroy</code> -&gt; <code>destoryed</code></p>
<p>​	vue3: <code>beforeCreate</code> -&gt; <code>created</code> -&gt; <code>beforeMount</code> -&gt; <code>mounted</code> -&gt; <code>beforeUpdate</code> -&gt; <code>updated</code> -&gt; <code>beforeUnmount</code> -&gt; <code>unmounted</code></p>
<p>​	其中，<code>beforeCreate</code> 时还没有 vue 实例。<code>created</code> 时 dom 未被渲染。<code>beforeMount</code> 时 dom 未被渲染， <code>mounted</code> 时 dom 已被渲染。</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td align="left">组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td align="left">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td align="left">在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td align="left">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td align="left">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td align="left">组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td align="left">keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td align="left">keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td align="left">组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td align="left">组件销毁后调用</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/haibolian/screenshot/raw/master/images/20220505134324.png" alt="组件生命周期图示"></p>
<h2 id="2-父子生命周期顺序"><a href="#2-父子生命周期顺序" class="headerlink" title="2. 父子生命周期顺序"></a>2. 父子生命周期顺序</h2><p>​	父 <code>beforeCreate</code> -&gt; 父 <code>created</code> -&gt; 父 <code>beforeMount</code> -&gt; 子 <code>beforeCreate</code> -&gt; 子 <code>created</code> -&gt; 子 <code>beforeMount</code> -&gt; 子 <code>mounted</code> -&gt; 父 <code>mounted</code></p>
<p>​	父组件先执行到 beforemount ，<strong>之后等待子组件挂在完毕</strong>，父组件才会执行 <code>mounted</code></p>
<p>​	更新也如此，父 <code>beforeUpdate</code> -&gt; 子 <code>beforeUpdate</code> -&gt; 子 <code>updated</code> -&gt; 父 <code>updated</code></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903918753808398#heading-8">参考链接</a></p>
<h2 id="3-父子组件传值"><a href="#3-父子组件传值" class="headerlink" title="3. 父子组件传值"></a>3. 父子组件传值</h2><ol>
<li><code>props</code>，父组件用来给子组件传值。通过 <code>.sync</code> 子组件可以向父组件更新 <code>prop</code> 的值</li>
<li><code>$emit</code>，子组件可通过 <code>$emit</code> 发射带参数的事件向父组件传值</li>
<li><code>provide、inject</code>， 父组件可以通过 <code>provide</code> 向后代组件传值，后代组件通过 <code>inject</code> 接收。不过此种方式并非响应式</li>
<li><code>bus</code> 传值，<code>new</code> 一个新的 <code>vue</code> 实例，通过 <code>$on</code> <code>$emit</code> 利用事件传值</li>
<li>通过 <code>parent</code>、<code>children</code>、<code>ref</code> 获取组件实例，进行修改或者取值</li>
<li>通过 $attrs&#x2F;$listeners 用于隔代的组件通信。$attrs 通常配合 inheritAttrs 一起使用</li>
<li><code>vuex</code></li>
</ol>
<h2 id="4-nextTick"><a href="#4-nextTick" class="headerlink" title="4. nextTick"></a>4. nextTick</h2><ol>
<li>nextTick是等待下一次 DOM 更新刷新的工具方法。</li>
<li>vue有个异步更新策路，意思是如果数据变化，vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策路导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的 DOM 状态，就需要使用 nextTick。</li>
<li>在Vue内部，nextTick 之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值。</li>
</ol>
<h2 id="5-vue的data为什么是函数返回而不是直接一个对象"><a href="#5-vue的data为什么是函数返回而不是直接一个对象" class="headerlink" title="5. vue的data为什么是函数返回而不是直接一个对象"></a>5. vue的data为什么是函数返回而不是直接一个对象</h2><p>当同一个组件被重复使用的时候，如果修改了组件 1 中的数据，如果是一个对象，那么则是一个引用类型，那么数据组件 2 中的数据也会同步修改。利用函数返回对象就可以避免使用同一个对象，保证两个组件中的数据互不影响。</p>
<h2 id="6-v-if-和-v-show-的区别"><a href="#6-v-if-和-v-show-的区别" class="headerlink" title="6. v-if 和 v-show 的区别"></a>6. v-if 和 v-show 的区别</h2><p>v-if 会从 dom 中删除元素</p>
<p>v-show 只是利用 css 的 display 来显示或隐藏元素</p>
<h2 id="7-computed-和-watch-的区别和运用的场景？"><a href="#7-computed-和-watch-的区别和运用的场景？" class="headerlink" title="7. computed 和 watch 的区别和运用的场景？"></a>7. computed 和 watch 的区别和运用的场景？</h2><ul>
<li><strong>computed</strong> 是计算属性，依赖于其他属性值，并且 computed 的值有缓存，只有它依赖的属性值发生变化，下一次获取 computed 时，computed 才会重新计算，值才发生变化，这也是 computed 和 method 的一个重要的区别。</li>
<li><strong>watch</strong> 监听一个属性，每当此属性发生变化时，都会执行 watch 的回调函数。</li>
</ul>
<p>当需要依赖多个属性进行计算或者组装时，可以定义一个 computed，多处使用该computde，只会执行一次，只有当内部依赖的属性发生变化时才会重新计算。</p>
<p>当一个属性变化时，需要执行异步或者开销较大的操作时，应该使用 watch。</p>
<blockquote>
<p>当 watch 监听和 computed 依赖同一个值时，watch 先执行、computed 后执行</p>
</blockquote>
<h2 id="8-讲讲-vue-响应式原理"><a href="#8-讲讲-vue-响应式原理" class="headerlink" title="8. 讲讲 vue 响应式原理"></a>8. 讲讲 vue 响应式原理</h2><ol>
<li><p>定义一个响应式方法，参数为 data，循环 data 中的数据，通过 <code>Object.defineProperty</code> 为 data 中每个属性添加 get 和 set 方法。</p>
<p><em>此处需要注意的是，如果 get 方法直接 return data[key]的话，会导致栈溢出，解决方法是使用闭包， 将值作为函数的参数传递进来，get 和 set 都对这个参数进行操作。</em></p>
</li>
<li><p>在 Vue 构造器中，执行响应式方法，通过 Vue 参数中的 el 创建一个编译类的实例</p>
</li>
<li><p>在编译类中，通过 el 获取到 dom，编译模板时，创建 Watcher 实例，添加到 Dep 实例中，收集依赖。 </p>
<p><em>Watcher 实例存储了 vue 实例，key，以及更新方法，在该方法中可以获取到 node。</em></p>
<p><em>Dep 实例定义 notice 方法，可以遍历收集到的依赖进行更新</em></p>
<p><em>可通过指定 Dep.target 是否有值，然后访问一下该属性的方式在响应式方法中将 watcher 实例添加到 Dep 中。</em></p>
</li>
<li><p>依赖收集完毕，接下来的动作就是派发更新了，在响应式函数的 <code>Object.defineProperty</code> 的 set 方法中，设置完值之后，通过 Dep 实例的notice 方法，遍历 watcher ，watcher 执行 update 方法。视图更新。</p>
</li>
</ol>
<blockquote>
<p><strong><code>Object.defineProperty</code></strong> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, props)</span><br></pre></td></tr></table></figure>

<p><strong><code>Object.defineProperties</code></strong> 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/haibolian/code-grocery/blob/main/vue%20%E5%93%8D%E5%BA%94%E5%BC%8F.js">手写响应式代码</a></p>
<h2 id="9-讲讲虚拟-dom"><a href="#9-讲讲虚拟-dom" class="headerlink" title="9. 讲讲虚拟 dom"></a>9. 讲讲虚拟 dom</h2><p>虚拟 dom 就是用 js 模拟真实的 dom 结构</p>
<p>利用虚拟 dom，可以减少dom 的操作次数，大大的提高了性能。</p>
<p><strong>虚拟 DOM 的实现原理</strong>主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<p><strong>虚拟 DOM 的优缺点</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<h2 id="10-讲讲-diff-算法"><a href="#10-讲讲-diff-算法" class="headerlink" title="10. 讲讲 diff 算法"></a>10. 讲讲 diff 算法</h2><ol>
<li><p>当组件创建和更新的时候， vue 会执行内部的 update 函数，该函数使用 render 函数生成虚拟的 dom 树，找到差异点，最终更新到真实dom</p>
</li>
<li><p>将新旧对比差异的过程叫 *diff ,*vue 在内部通过一个叫做 patch 的函数来完成该过程。</p>
</li>
<li><p>在对比的过程，vue 采用深度优先，同级比较的方式进行比较，同级比较就是说它不会跨越结构进行比较，在判断两个节点是否相同的时候，是根据虚拟节点的 key 和 tag 来进行判断的。</p>
</li>
<li><p>具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。</p>
</li>
<li><p>在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。</p>
</li>
<li><p>这样一直递归的遍历下去，直到整棵树完成对比。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6958292554047553549">参考内容（写的很清晰）</a></p>
<h2 id="11-为什么-vue-检测不到给数组项赋值"><a href="#11-为什么-vue-检测不到给数组项赋值" class="headerlink" title="11. 为什么 vue 检测不到给数组项赋值"></a>11. 为什么 vue 检测不到给数组项赋值</h2><p>在 vue2 中，vue 响应式是通过 <code>Object.defineProperty</code> 实现，而数组不可能都事先定义好数据，所以 vue 无法监听到。</p>
<p>可以通过 Vue.set 或者 vm.$set 对数组进行赋值</p>
<p>另外，vue 对数组的 push、splice 等一些方法也做了响应式处理，执行这些数组的方法也可以让 vue 检测到</p>
<h2 id="12-父组件如何监听子组件的生命周期"><a href="#12-父组件如何监听子组件的生命周期" class="headerlink" title="12. 父组件如何监听子组件的生命周期"></a>12. 父组件如何监听子组件的生命周期</h2><p><strong>两种方法</strong></p>
<ul>
<li><p>通过 emit 事件方式：在子组件的生命周期中向父组件发射事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Parent.vue</span><br><span class="line">&lt;Child @mounted=&quot;doSomething&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">// Child.vue</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$emit(&quot;mounted&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 hook 的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//  Parent.vue</span><br><span class="line">&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   console.log(&#x27;父组件监听到 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">//  Child.vue</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&#x27;子组件触发 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line">// 以上输出顺序为：</span><br><span class="line">// 子组件触发 mounted 钩子函数 ...</span><br><span class="line">// 父组件监听到 mounted 钩子函数 ...   </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-谈谈你对-keep-alive-的了解"><a href="#13-谈谈你对-keep-alive-的了解" class="headerlink" title="13. 谈谈你对 keep-alive 的了解"></a>13. 谈谈你对 keep-alive 的了解</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，当再次加载组件时，会从缓存中获取该组件 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<blockquote>
<p>如果多个组件内容比较简单，也可以使用 v-show 的方式替代 keep-alive，如果比较复杂，太影响首次加载的性能时，可以使用 keep-alive</p>
</blockquote>
<h2 id="14-v-model-的原理"><a href="#14-v-model-的原理" class="headerlink" title="14. v-model 的原理"></a>14. v-model 的原理</h2><p>v-model 的本质只不过是一个语法糖，v-model 在内部为不同的输入元素使用不同的属性向外抛出不同类型的事件</p>
<ul>
<li>text 和 textarea 元素使用 value属性 和 input事件</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件</li>
</ul>
<p>在自定义组件中，默认使用 value属性 和 input事件</p>
<h2 id="15-vue-router-中-hash-和-history-路由模式实现原理"><a href="#15-vue-router-中-hash-和-history-路由模式实现原理" class="headerlink" title="15. vue-router 中 hash 和 history 路由模式实现原理"></a>15. vue-router 中 hash 和 history 路由模式实现原理</h2><p><strong>hash模式实现原理</strong></p>
<ul>
<li><p>location.hash 就是 url # 后面的内容，向服务器发送请求时，hash 部分不会被发送，hash 值的变化会在浏览器中记录，可以通过前进后退来进行 hash 值的改变。</p>
</li>
<li><p>可以通过 a 标签或 JavaScript 来对 hash 进行赋值。</p>
</li>
<li><p>通过 hashchange 来监听 hash 值的变化，从而对页面进行跳转。</p>
</li>
</ul>
<p><strong>history 模式实现原理</strong></p>
<p>history 模式使用 HTML5 提供的history API 来实现 url 的变化。主要使用的 API 是 <code>history.pushState()</code> 和 <code>history.repalceState()</code> 。这两个 API 都可以在不刷新页面的情况下，实现 URL 的改变。<code>history.pushState </code> 是新增一个记录，<code>history.replaceState</code> 是替换当前的历史记录。</p>
<p>history 模式的实现主要基于以下几个特性：</p>
<ul>
<li><code>history.pushState</code> 和<code>history.replaceState</code> 两个 API 来操作实现URL 变化；</li>
<li>使用 <code>popstate</code> 事件监听 URL 变化，从而对页面进行渲染；</li>
<li>但是呢 <code>history.pushState</code> 和<code>history.replaceState</code>的调用并不会触发 <code>popstate</code> 事件。只有在做出浏览器动作时，才会触发。这时我们需要手动触发页面跳转（渲染）。比如在 js 中调用  <code>history.back</code> 。</li>
</ul>
<h2 id="16-MVVM"><a href="#16-MVVM" class="headerlink" title="16. MVVM"></a>16. MVVM</h2><p>MVVM 分为 View 层、ViewModel 层、Model 层。</p>
<ul>
<li><strong>View 层：</strong>视图层，用户看到的界面</li>
<li><strong>Model 层：</strong>数据模型层，也就是后端的业务逻辑、数据操作。对前端来说就是后端提供的接口 API，</li>
<li><strong>ViewModel 层：</strong>视图数据层，在这一层，前端对后端接口返回的数据进行二次封装，生成符合 View 层的数据。在 ViewModel 层所封装出来的数据包括状态和行为，状态也就是 View 层所需要显示的数据，行为也就是用户和 View 层交互时发生的事件，比如各种事件，点击时的行为。</li>
</ul>
<p>MVVM 模式促进了前端页面和后端业务逻辑处理的分离，MVVM 的核心是 ViewModel ，前端开发只需要重点关注 ViewModel 层，后端开发也只需要关注业务逻辑。View 层展示的数据也不在是Model 层，而是 ViewModel 层对 Model 层处理后的数据，这样就完全解耦了 View 层和 Model 层。这也是前后端分离的重要一环。	</p>
<h2 id="17-Vue-中的-key-有什么作用"><a href="#17-Vue-中的-key-有什么作用" class="headerlink" title="17. Vue 中的 key 有什么作用"></a>17. Vue 中的 key 有什么作用</h2><p>key 是 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p>
<h2 id="18-Vue-性能优化方案"><a href="#18-Vue-性能优化方案" class="headerlink" title="18. Vue 性能优化方案"></a>18. Vue 性能优化方案</h2><ol>
<li>区分 v-show、v-if</li>
<li>v-for 加 key</li>
<li>根据具体情况合理使用 computed、watch</li>
<li>大量不需要响应式的数据，不需要响应式的数据就不需要 Vue 对其进行数据劫持，可以使用 <code>Object.freeze</code> 方法冻结对象。减少初始化的时间。</li>
<li>事件销毁，在 Vue 组件销毁时，vue 会自动清理它的实例连接，解绑这个组件的指令、事件监听器，但是这只限于组件的本身，在 mounted 时，使用 dom 定义的addEventListener，Vue 并不会自动销毁，这时，我们需要手动销毁这些事件监听，以免造成内存浪费和内存泄漏。</li>
<li>图片资源的懒加载。</li>
<li>使用精灵图。</li>
<li>路由的懒加载。</li>
<li>第三方插件的按需引入，如 Element 组件如果用的不多的情况下，可以按需引入。</li>
</ol>
<h2 id="19-proxy-和-Object-defineProperty-优劣对比"><a href="#19-proxy-和-Object-defineProperty-优劣对比" class="headerlink" title="19. proxy 和 Object.defineProperty 优劣对比"></a>19. proxy 和 Object.defineProperty 优劣对比</h2><p><code>Object.defineProperty</code> 的优势是兼容性好</p>
<p><code>proxy</code> 的优势就比较多了：</p>
<ol>
<li>proxy 可以直接监听对象而非属性</li>
<li>proxy 可以监听数组的变化</li>
<li>proxy 返回的是一个新的对象，我们可以操作这个新的对象从而达到目的。而 <code>Object.definePropery</code> 只能通过遍历对象的属性进行修改。</li>
</ol>
<h2 id="20-SPA首屏加载速度慢的怎么解决"><a href="#20-SPA首屏加载速度慢的怎么解决" class="headerlink" title="20. SPA首屏加载速度慢的怎么解决"></a>20. SPA首屏加载速度慢的怎么解决</h2><ol>
<li>Vue-Router路由懒加载（利用Webpack的代码切割）</li>
<li>使用CDN加速，将通用的库从vendor进行抽离</li>
<li>Nginx的gzip压缩</li>
<li>Vue异步组件</li>
<li>服务端渲染SSR</li>
<li>如果使用了一些UI库，采用按需加载</li>
<li>图片懒加载减少占用网络带宽</li>
<li>页面使用骨架屏</li>
<li>利用好script标签的async和defer这两个属性。功能独立且不要求马上执行的js文件，可以加入async属性。如果是优先级低且没有依赖的js，可以加入defer属性。</li>
</ol>
<p>可利用<code>performance.timing</code>看各个步骤的耗时：白屏时间：<code>performance.timing.responseStart \- performance.timing.navigationStart</code></p>
<h2 id="21"><a href="#21" class="headerlink" title="21."></a>21.</h2><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="1-Vuex有哪些基本属性，为什么mutation不能做异步操作"><a href="#1-Vuex有哪些基本属性，为什么mutation不能做异步操作" class="headerlink" title="1. Vuex有哪些基本属性，为什么mutation不能做异步操作"></a>1. Vuex有哪些基本属性，为什么mutation不能做异步操作</h2><ul>
<li>state：用来存放一些共享的数据</li>
<li>mutations：存放修改数据的方法，同步</li>
<li>actions：发送异步请求</li>
<li>getters：类似于computed，基于 state 创建新的数据</li>
<li>modules：模块化，可以创建命名空间，每个模块维护自己的状态。</li>
</ul>
<p>因为开发过程中，我们常常会追踪状态的变化，如果在mutation中通过异步操作来更新state中的数据，虽然在页面的显示效果上没有什么影响，但是会导致开发工具不能追踪到状态的改变，调试起来会很困难。</p>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="1-跨域解决方案"><a href="#1-跨域解决方案" class="headerlink" title="1. 跨域解决方案"></a>1. 跨域解决方案</h2><ol>
<li><p><code>webpack</code> 中的 <code>proxy</code> 代理</p>
</li>
<li><p><code>nginx</code> 反向代理</p>
</li>
<li><p><code>jsonp</code>：通过 <code>script</code> 标签发送网络请求，利用回调函数获取数据</p>
<p>  前端创建 script 标签，src 为请求地址，在请求参数中，指定回调函数名称。回调函数的参数用来接收数据。例如： <code>src=&quot;localhost:3000/users/getInfo?username=admin&amp;callback=func&quot;</code></p>
<p>  服务端返回该回调函数名称 + 数据 组成的结果。例如：<code>res.end(&#39;func(&#39; + data + &#39;)&#39;);</code></p>
<p>  <strong>缺点：</strong>只支持 get 请求。</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/badmoonc/article/details/82289252">参考链接</a></p>
</li>
<li><p><code>postMessage</code>： <code>html5</code> 引入了<code>message</code> 的 api ，方便、有效、安全。<code>postMessage</code> 方法允许来自不用源的脚本采用异步的方式进行通讯。可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>  postMessage 接收两个参数：</p>
<ul>
<li><code>data</code> ：要传递的数据。</li>
<li><code>origin</code>：目标窗口的源。</li>
</ul>
<p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphinX/p/3464056.html">参考链接</a></p>
</li>
<li><p><code>cors</code> 跨域资源共享。 <code>cors</code> 分为简单请求和非简单请求。<br><strong>简单请求：</strong></p>
<ol>
<li>请求方式为 HEAD、GET、POST 三者之一</li>
<li>http 头部信息不超过以下几种字段</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Type: 只限于 application&#x2F;x-www-form-urlencode、multipart&#x2F;form-data、text&#x2F;plain 三种</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
</ul>
<p><strong>非简单请求：</strong> 不满足以上两种条件，均为非简单请求<br><strong>简单请求处理方式：</strong> 对于简单请求，浏览器直接发出 CORS 请求，并自定在头部信息增加一个字段：Origin，用来说明本次请求来自哪个源（协议 + 域名 + 端口）；服务器判断该 Origin 决定是否同意本次请求，若同意本次请求，则在响应中添加三个与 CORS 相关的字段，均以 <code>Access-Control-</code> 开头：</p>
<ol>
<li><p><code>Access-Control-Allow-Origin</code>：必选，本次请求的 Origin 的值 或者 *</p>
</li>
<li><p><code>Access-Control-Allow-Credentials</code>：可选，布尔值，表示是否允许发送 cookie。默认情况下，cookie 不包含在 CORS 中。</p>
</li>
<li><p><code>Access-Control-Expose-Headers</code>：可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader 方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，必须在 <code>Access-Control-Expose-Headers</code> 中指定。getResponseHeader使用方法例如 getResponseHeader(‘FooBar’)</p>
</li>
<li><p>withCredentials： 如果要把 cookie 发送给服务器，一方面要经过服务器的同意，即服务器设置了 <code>Access-Control-Allow-Credentials = true</code>。另一方面，前端开发也需要在 ajax 打开 withCredentials 属性。</p>
<blockquote>
<p>需要注意的是，如果要发送 cookie <code>Access-Control-Allow-Origin</code> 不能设置为星号（*），必须指定明确的，与请求网页一致的域名。同时，coolie 也遵循同源政策，只有用服务器域名设置的 cookie 才会上传，其他域名不会上传。</p>
</blockquote>
</li>
</ol>
<p><strong>非简单请求的处理方式：</strong></p>
<ol>
<li><p>预检请求：在 CORS 发送正式请求之前，会先对服务器发送一个 method 为 OPTIONS 的预检请求，先询问服务器，该网页所属的域名是否在服务器允许的范围中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到正确的答复，浏览器才会发送正式的请求。</p>
<p>预检请求的头部信息还包含三个特殊的字段：</p>
<p><strong><code>Origin</code></strong> 必选 ，表示请求来自哪个源。</p>
<p>**<code>Access-Control-Request-Method </code>**：必选，用来列出浏览器的 CORS 请求会用到哪些 http 方法。</p>
<p><strong><code>Access-Control-Request-Headers</code></strong> ：可选，逗号分隔，指定浏览器的 CORS 请求会额外发送的头部信息。</p>
</li>
<li><p>预检请求回应：服务器收到预检请求后，根据请求头部信息做出相应处理。关键的是 <code>Aceess-Control-Allow-Origin</code> 表示允许请求的域名。服务器回应的其他字段如下：</p>
<p><code>Access-Control-Allow-Methods</code></p>
<p><code>Access-Control-Allow-Headers</code>： 如果浏览器发送的请求包含<code>Access-Control-Request-Headers</code> ，则该项是必需的。</p>
<p><code>Access-Control-Allow-Credentials</code></p>
<p><code>Access-Control-Max-Age</code>：表示此次预检请求的有效期，在此有效期间，不用发送另一条预检请求。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">参考链接</a></p>
</li>
</ol>
<h2 id="2-强缓存和协商缓存"><a href="#2-强缓存和协商缓存" class="headerlink" title="2. 强缓存和协商缓存"></a>2. 强缓存和协商缓存</h2><ul>
<li><p>强缓存</p>
<p>浏览器第一次访问服务器，服务器返回一个 200 状态码，并且带有响应内容的返回，响应头中含有 cache-control，值为 max-age &#x3D; ***，表示过期时间。还有 no-cache 也可以作为值。</p>
<p>当浏览器第二次访问服务器时，如果访问时间在 max-age 之内，就会命中强缓存，返回 200 状态码，响应内容是缓存的内容。</p>
</li>
<li><p>协商缓存</p>
<p>浏览器第一次发送请求，服务器返回 200 状态码和正确的资源，响应头中含有资源标识，就像是个资源版本，当浏览器再次访问服务器时，服务器会根据请求头中的资源标识和服务端的资源标识对比：</p>
<p>如果相同则返回 304，浏览器从缓存中取得资源</p>
<p>如果不同则同于一次完整的请求，返回 200 状态码，和正确资源。</p>
<p>资源标识如下：</p>
<ul>
<li><strong>Last-Modify&#x2F;If-Modify-Since：</strong>服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。</li>
<li><strong>Etag：</strong>web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。</li>
<li><strong>If-None-Match：</strong>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；</li>
</ul>
</li>
</ul>
<h2 id="3-三次握手"><a href="#3-三次握手" class="headerlink" title="3. 三次握手"></a>3. 三次握手</h2><p>第一次握手：客户端向服务端发送 SYN(j) 建立连接请求，客户端进入 SYN_SEND 状态。<em>此时客户端有没有发送的能力尚未知晓</em></p>
<p>第二次握手：服务端接收到客户端的请求，并向客户端发送 SYN(k)，和 ACK(j+1)，服务端进入 SYN_RECV 状态。<em>此时能确定客户端的发送能力和服务端的接收能力</em></p>
<p>第三次握手：客户端接收来自服务端的发送的 SYN 和 ACK，并向服务端发送确认包 ACK（k + 1），这个包发送完毕，服务端和客户端进入ESTABLISHED 状态。<em>确定服务端的发送能力和客户端的接收能力</em>。完成三次握手，客户端可以向服务端发送资源请求。</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1693383134922615393&wfr=spider&for=pc">关于三次握手和四次挥手</a></p>
<h2 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4. 四次挥手"></a>4. 四次挥手</h2><p>第一次挥手：客户端向服务端发送 FIN 报文，请求连接终止(FIN &#x3D; 1)，此时客户端状态为 FIN_WAIT_1</p>
<p>第二次挥手：服务端接收到 FIN 报文后，可能还有没发送完的数据，于是先向客户端发送一个 ACK 报文，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</p>
<p>第三次挥手：服务端没有要发送的数据了，可以关闭了，于是服务端向客户端发送 FIN 报文，此时服务端处于 LAST_ACK 状态</p>
<p>第四次挥手：客户端收到FIN之后，会向服务端发送 ACK 作为应答， 此时客户端处于 TIME_WAIT 状态</p>
<h2 id="5-http-常见状态码"><a href="#5-http-常见状态码" class="headerlink" title="5. http 常见状态码"></a>5. http 常见状态码</h2><p>[http 常见状态码](..&#x2F;http&#x2F;http 常见状态码)</p>
<h2 id="6-HTTP-请求报文结构"><a href="#6-HTTP-请求报文结构" class="headerlink" title="6. HTTP 请求报文结构"></a>6. HTTP 请求报文结构</h2><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="1-前端性能优化方案"><a href="#1-前端性能优化方案" class="headerlink" title="1. 前端性能优化方案"></a>1. 前端性能优化方案</h2><ul>
<li><p>css</p>
<ol>
<li>使用精灵图，将多个图标或图片放到一个图片中，通过 <code>background</code> 来显示相应的图片</li>
<li>移除空的 css 规则</li>
<li>充分利用 css 的继承属性，减少代码量</li>
<li>提取公共样式，减少代码量</li>
</ol>
</li>
<li><p>js</p>
<ol>
<li>节流、防抖</li>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/220662.htm">图片懒加载</a></li>
<li>如果需要添加很多 dom，先把节点通过 createElement 创建出来最后一次性加入 dom</li>
<li>批量绑定事件时，使用事件委托，利用事件冒泡使父节点实现。</li>
<li>当使用对象的多个或重复的某个属性时，使用ES6 的解构赋值，减少对对象的访问，尤其是 vue2 中的 this</li>
</ol>
</li>
<li><p>网络</p>
<p>尽可能减少 http 请求次数</p>
</li>
</ul>
<h2 id="2-浏览器内核"><a href="#2-浏览器内核" class="headerlink" title="2. 浏览器内核"></a>2. 浏览器内核</h2><p>浏览器内核主要分成两部分，渲染引擎和 js 引擎。</p>
<p><strong>渲染引擎</strong>负责获取页面的内容，计算网页的显示方式，输出给显示器。浏览器内核的不同对于网页的语法和解释会有所不同，所以渲染效果也可能不同。</p>
<p><strong>js 引擎</strong>则解析和执行 js 来实现网页的动态效果。</p>
<p><strong>常见的浏览器内核有</strong></p>
<p>IE：trident</p>
<p>Chrome：以前是 webkit，现在是Blink</p>
<p>火狐：Gecko</p>
<p>safari：webkit</p>
<p>opera：从 webkit 到 blink </p>
<h2 id="3-从输入网址回车到页面显示过程"><a href="#3-从输入网址回车到页面显示过程" class="headerlink" title="3. 从输入网址回车到页面显示过程"></a>3. 从输入网址回车到页面显示过程</h2><ol>
<li><p>通过 DNS 解析域名的实际 IP</p>
</li>
<li><p>检查浏览器是否有强缓存，有则取本地的 html</p>
</li>
<li><p>没有的强缓存，则与 web 服务器建立 tcp 链接，服务器通过请求参数检查是否协商缓存。有的话返回状态码 304，没有的话返回请求资源</p>
</li>
<li><p>TCP 协议通过三次握手建立链接</p>
<ol>
<li>客户端发送 syn(j) 报文段请求链接，确定服务端是否开始端口准备链接。客户端状态为 SYN_SEND</li>
<li>服务器如果开启端口并准备接受链接，则会向客户端返回 SYN(k) + ACK(j+1) 报文段给客户端，服务端状态为 SYN_RECV</li>
<li>客户端收到 SYN + ACK 包，向服务端发送确认包 ACK(k+1)，这个包发送完毕，客户端和服务端进入ESTABLISHED状态，完成三次握手，客户端和服务端开始传输数据。</li>
</ol>
</li>
<li><p>建立链接后，浏览器请求页面资源</p>
</li>
<li><p>服务器发送资源</p>
</li>
<li><p>浏览器获取到资源后，解析HTML，如果解析到<code>style</code>标签则开始解析css，如果解析到link标签则先异步下载，完成后解析css。</p>
<p>如果遇到<code>script</code>标签，判断是行内写法则直接解析执行，如果是src引入则<code>同步下载</code>脚本文件，下载完成<code>立即执行</code>，注意这里下载过程是<code>阻塞</code>的，其他流程都会等下载完成后执行。</p>
</li>
<li><p>然后开始渲染页面，解析 HTML, 构建 DOM 树，然后解析 css，生成 css 规则树</p>
<p>合并 DOM 树和 css 规则树，生成渲染树render</p>
<p>浏览器开始布局 render树，根据各节点的大小，位置进行计算，得到每个节点的几何信息</p>
<p>最后浏览器将各个节点的信息发送给GPU，GPU 绘制页面展示到显示器上。</p>
</li>
</ol>
<h2 id="4-cookies、sessionStorage、localStorage-和-indexDB-的区别"><a href="#4-cookies、sessionStorage、localStorage-和-indexDB-的区别" class="headerlink" title="4. cookies、sessionStorage、localStorage 和 indexDB 的区别"></a>4. cookies、sessionStorage、localStorage 和 indexDB 的区别</h2><p>cookie是以文本的方式保存在客户端，每次请求时都带上它。 单个cookie保存的数据不能超过4kb。</p>
<p> 默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th>生命周期</th>
<th>存储容量</th>
<th>存储位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cookie</td>
<td>默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）</td>
<td>4KB</td>
<td>保存在客户端，每次请求时都会带上</td>
</tr>
<tr>
<td align="left">localStorage</td>
<td>理论上永久有效的，除非主动清除。</td>
<td>4.98MB（不同浏览器情况不同，safari 2.49M）</td>
<td>保存在客户端，不与服务端交互。节省网络流量</td>
</tr>
<tr>
<td align="left">sessionStorage</td>
<td>仅在当前网页会话下有效，关闭页面或浏览器后会被清除。</td>
<td>4.98MB（部分浏览器没有限制）</td>
<td>同上</td>
</tr>
</tbody></table>
<p><strong>indexDB  和 webSQL</strong> 是前端的一种数据库，没用过</p>
<h2 id="5-浏览器的渲染引擎工作原理"><a href="#5-浏览器的渲染引擎工作原理" class="headerlink" title="5. 浏览器的渲染引擎工作原理"></a>5. 浏览器的渲染引擎工作原理</h2><p>在浏览器下载完html、css、js图片后，就会开始渲染页面</p>
<ol>
<li>首先，解析HTML，构建DOM树</li>
<li>然后解析CSS，生成CSS规则树</li>
<li>然后合并DOM树和CSS规则树，生成一个渲染树，也就是render树</li>
<li>开始布局render树，根据render树来对各个元素的大小，位置进行计算，得到每个节点的几何信息。它是根据浏览器视口的大小来计算元素的位置和大小。重排会走到这一步。</li>
<li>开始绘制 render 树，绘制页面的像素信息，根据渲染树节点的几何信息，得到每个节点的像素数，重绘会走到这一步。</li>
<li>最后浏览器将各个层次的节点信息发送给GPU，GPU绘制展示到页面上。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7075515261121626119">参考资料1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/padding1015/p/11405788.html">参考资料2</a></p>
<h2 id="6-重排和重绘"><a href="#6-重排和重绘" class="headerlink" title="6. 重排和重绘"></a>6. 重排和重绘</h2><p><strong>重排</strong></p>
<p>当DOM变化影响了元素的几何属性，比如宽高，浏览器会重新计算元素的几何属性，同样的，和它相邻的元素的几何属性和位置也会受到影响，浏览器会对这些受影响的元素重新构造render树并布局render树。</p>
<p><strong>重绘</strong></p>
<p>重排之后，浏览器会重新绘制受影响的部分到屏幕中，会重新根据元素的几何信息计算像素数。这个过程就是重绘。</p>
<h2 id="7-哪些情况会导致重绘和重排，如何减少"><a href="#7-哪些情况会导致重绘和重排，如何减少" class="headerlink" title="7. 哪些情况会导致重绘和重排，如何减少"></a>7. 哪些情况会导致重绘和重排，如何减少</h2><p><strong>以下几个动作可能会导致性能问题</strong>：</p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<p><strong>如何减少重绘和重排</strong>：</p>
<ol>
<li>使用 <code>transform</code> 替代 <code>top</code></li>
<li>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多</li>
<li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</li>
<li>避免使用<code>css</code>表达式(<code>expression</code>)，因为每次调用都会重新计算值（包括加载页面）</li>
<li>批量修改元素样式：<code>elem.className</code> 和 <code>elem.style.cssText</code> 代替 <code>elem.style.xxx</code></li>
<li>需要要对元素进行复杂的操作时，可以先隐藏(<code>display:&quot;none&quot;</code>)，操作完成后再显示</li>
<li>需要创建多个<code>DOM</code>节点时，使用<code>DocumentFragment</code>创建完后一次性的加入<code>document</code></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gJQ81EVxjzm10yX_fxAp8w">参考文章</a></p>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="1-说说你对webpack的理解？解决了什么问题"><a href="#1-说说你对webpack的理解？解决了什么问题" class="headerlink" title="1. 说说你对webpack的理解？解决了什么问题"></a>1. 说说你对webpack的理解？解决了什么问题</h2><p>webpack是js的静态模块打包工具</p>
<p><strong>解决了什么问题</strong></p>
<ol>
<li>webpack可以实现模块打包，将各个模块之间的依赖关系构建依赖图，将各个模块打包成一个或多个js文件，实现前端模块化。</li>
<li>webpack可以解决浏览器兼容性问题，通过引入实现浏览器兼容的loader，通过这些loader实现浏览器兼容，还可以根据这些loader对一些开发中使用的文件类型进行编译转换，如less，sass，vue，jsx文件。</li>
</ol>
<h2 id="2-webpack的构建流程"><a href="#2-webpack的构建流程" class="headerlink" title="2. webpack的构建流程"></a>2. webpack的构建流程</h2><ol>
<li>读取webpack配置文件参数</li>
<li>根据配置参数创建compiler对象，开始解析项目</li>
<li>从入口文件开始解析，调用所有配置的loader对模块进行翻译，找到其导入的依赖模块，递归遍历并通过loader处理。</li>
<li>形成依赖关系树，根据入口和模块之前的关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表。</li>
<li>根据配置参数中的输出路径，把文件内容写入到文件系统。</li>
</ol>
<h2 id="3-webpack中常见的Loader？解决了什么问题？"><a href="#3-webpack中常见的Loader？解决了什么问题？" class="headerlink" title="3. webpack中常见的Loader？解决了什么问题？"></a>3. webpack中常见的Loader？解决了什么问题？</h2><ol>
<li>sass-loader、less-loader：把scss和less代码转换成css</li>
<li>css-loader：负责解析css代码，支持模块化，css文件的导入的特性，并不会将解析后的css插入到页面中。</li>
<li>style-loader：把css-loader生成的内容用style标签挂载到页面的head中。</li>
<li>postcss-loader：处理css兼容，需要配合autoprefixer 和 postcss-preset-env 插件一起使用。 autoprefixer 和 postcss-preset-env 根据 browsersliset 返回的浏览器版本进行前缀添加。其实postcss-preset-env 中已经包含了 autoprefixer，所以直接用postcss-preset-env插件就行了。</li>
<li>babel-loader：把ES6语法转换成ES5</li>
<li>image-loader：加载并压缩图片文件</li>
<li>file-loader：把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</li>
<li>raw-loader：在 webpack中通过 import方式导入文件内容，该loader并不是内置的，所以首先要安装</li>
<li>url-loader：可以处理理 file-loader 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，对小体积的图片比较合适，大图片不合适。</li>
</ol>
<h2 id="4-说说webpack中常见的Plugin？解决了什么问题？"><a href="#4-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="4. 说说webpack中常见的Plugin？解决了什么问题？"></a>4. 说说webpack中常见的Plugin？解决了什么问题？</h2><ol>
<li>HtmlWebpackPlugin：自动生成一个 html 文件，并把打包后的 js 文件添加到里面。可以指定 html 模板。</li>
<li>clean-webpack-plugin：清理打包目录</li>
<li>DefinePlugin：在编译时创建配置的全局对象，是一个webpack内置的插件，不需要安装</li>
<li>copy-webpack-plugin：复制文件或目录到执行区域，如vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中</li>
</ol>
<h2 id="5-说说Loader和Plugin的区别"><a href="#5-说说Loader和Plugin的区别" class="headerlink" title="5. 说说Loader和Plugin的区别"></a>5. 说说Loader和Plugin的区别</h2><p><strong>Loader</strong> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。<br>因为 Webpack 只认识 js，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p>
<p><strong>Plugin</strong> 就是插件，可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p>Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p>
<p>Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p>
<h2 id="6-说说webpack的热更新是如何做到的？原理是什么"><a href="#6-说说webpack的热更新是如何做到的？原理是什么" class="headerlink" title="6. 说说webpack的热更新是如何做到的？原理是什么"></a>6. 说说webpack的热更新是如何做到的？原理是什么</h2><p>热更新就是在启动服务后，修改代码后，浏览器只针对修改的模块进行更新，并不影响其他模块。</p>
<p>当我们在编写还没有经webpack打包的源代码后，webpack Compile 将源代码和 HMR runtime 一起编译成bundle文件传给Bundle Server服务器，Bundle Server服务器就是一个静态资源服务器，HMR runtime 是一个socket服务器，它会被注入到浏览器，通过和HMR Server建立长连接，HMR server用来将更新的文件输出给HMR runtime，更新文件的变化。</p>
<p>当某一个文件发生变化时，webpack监听到文件变化对它重新打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识。</p>
<p>根据变化的内容，生成两个补丁文件，manifest （包含了hash和chunkId，用来说明变化的内容）和 chunk.js模块</p>
<p>服务器向浏览器推送消息，消息包含文件改动后的值和hash值和改动后生成的hash值。</p>
<p>浏览器拿到推送的消息之后，通过 HMR runtime机制，加载这两个文件，针对修改的文件进行更新。</p>
<p><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/webpack/HMR.html#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">参考文档</a></p>
<h2 id="7-webpack-proxy工作原理？为什么能解决跨域"><a href="#7-webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="7. webpack proxy工作原理？为什么能解决跨域"></a>7. webpack proxy工作原理？为什么能解决跨域</h2><p>浏览器和服务器之间可能会存在跨域，但服务器之间不存在跨域</p>
<p>因为webpack-dev-server 就是启动了一个本地服务器，所以浏览器发起的请求会让本地的服务器去代理发送，这样就不会产生跨域了。</p>
<p>然后通过proxy的配置，指定要代理请求的服务器和请求路径。</p>
<h2 id="8-如何借助webpack来优化前端性能？"><a href="#8-如何借助webpack来优化前端性能？" class="headerlink" title="8. 如何借助webpack来优化前端性能？"></a>8. 如何借助webpack来优化前端性能？</h2><h2 id="9-如何提高webpack的构建速度"><a href="#9-如何提高webpack的构建速度" class="headerlink" title="9. 如何提高webpack的构建速度"></a>9. 如何提高webpack的构建速度</h2><h1 id="阿里成本管理系统"><a href="#阿里成本管理系统" class="headerlink" title="阿里成本管理系统"></a>阿里成本管理系统</h1><h2 id="1-如果实现权限分配的"><a href="#1-如果实现权限分配的" class="headerlink" title="1. 如果实现权限分配的"></a>1. 如果实现权限分配的</h2><p>角色路由权限是放在了后端。</p>
<p>由前端定义好所有的路由，在路由配置页面配置好指定角色具有的路由。</p>
<p>登录后，前端通过接口拿到该用户的路由表，然后根据前端本地的路由比较，根据接口的路由表，对两个路由表的字段根据情况进行取舍，生成一份新的该用户的路由表，添加到 router 上面 并且存到stroe里面。</p>
<p>接口的路由表还可以配置一些按钮的权限，在路由表中的每个页面增加按钮编码组成的数组，前端把页面和按钮组组成一个映射放到store里，在页面里就可以根据该页面的按钮数组来判断是否渲染按钮。</p>
<h2 id="2-大数据表格的实现"><a href="#2-大数据表格的实现" class="headerlink" title="2. 大数据表格的实现"></a>2. 大数据表格的实现</h2><ol>
<li>根据给定表格的高度，和表格每一行的高度，计算出表格能够看到的部分一共有多少行，表格 body 渲染时，就渲染这些数据。</li>
<li>外层需要一个 div ，利用 <code>overflow: auto</code> 来显示出滚动条，这时就需要撑高这个表格，可是表格渲染的数据只有可视部分的行数。</li>
<li>利用 <code>padding-top</code> 和 <code>padding-bottom</code> 来撑高这个表格，这时就需要计算这两个 padding 。需要用到两个索引，一个是 startIndex 和 endIndex， 分别表示可视部分最上面和最下面的所在行数的索引 ，比如可视部分是 10 行，那么startIndex 和 endIndex 分别是 0 和 9，那么利用这两个 index 和 总数据条数还有每一行的高度，就可以把这两个 padding 计算出来。表格的滚动条就出来了。</li>
<li>添加滚动事件，根据事件的 target.scrollTop 属性重新计算startIndex 和 endIndex ，然后根据这个两个 index 截取数据给表格去渲染。</li>
</ol>
<p><strong>使用 padding 导致重排问题：</strong></p>
<p>频繁更改 padding 会导致重排，影响性能，可以利用 translateY 来使表格进位位移：</p>
<ol>
<li>思路：表格 translateY，那么就不能利用表格来撑开高度了，可以使用一个空的 div，让这个空的 div 来撑开高度，进而让上一层的 div 显示滚动条</li>
<li>空的 div 占据了整个高度，那么表格需要绝对定位来脱离文档流，给上一层 div 加个相对定位，这就在滚动时可以利用 translateY 来对表格进行位移了。</li>
</ol>
<h2 id="3-树形表格虚拟渲染"><a href="#3-树形表格虚拟渲染" class="headerlink" title="3. 树形表格虚拟渲染"></a>3. 树形表格虚拟渲染</h2><p>树形表格虚拟渲染需要一个通过id 和 parentId 来确定依赖关系的数组</p>
<p>树形表格的虚拟渲染的主要难点是主要是如何将一个不规则的、无序的数组制作成有序的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 把一个散的数组做成一个有顺序的数组</span><br><span class="line">// 把所有的 parent 拎起来，list 是一个对象，遍历散数组，以 parentId 为 key，将所有的子项挂到 parent 上面。</span><br><span class="line">// 此时 list 对象的每一项是个数组，遍历这个数组，给数组的每一项挂上 children，这个 children 就在 list 这个 map 里面去取。</span><br><span class="line">// 已经挂上了 children，由于引用类型，所以只需要取 list[0] 这一项，就可以拿到一个从根开始的一颗树</span><br><span class="line">// 递归这棵树，就可以生成一个根据 id 和 parentId 排好序一个数组。</span><br></pre></td></tr></table></figure>

<p>有了这个有序的数组，就可以根据滚动位置 scrollLeft、scrollTop 、表格高度、每一行的高度来计算需要显示的数据。</p>
<h2 id="3-手写金额格式化函数"><a href="#3-手写金额格式化函数" class="headerlink" title="3. 手写金额格式化函数"></a>3. 手写金额格式化函数</h2><h2 id="4-加减乘除的实现"><a href="#4-加减乘除的实现" class="headerlink" title="4. 加减乘除的实现"></a>4. 加减乘除的实现</h2><p>核心思路是把 避免使用小数计算，两个要计算的数转换成整数 来进行计算。</p>
<p>将数组转成字符串，利用字符串的split方法计算小数位长度，利用replace将小数点去掉。</p>
<p>这时就可以用没有小数点的两个数进行计算，然后根据加减乘除的情况去乘以10的多少次方</p>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2></div></article><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#html"><span class="post-toc-number">1.</span> <span class="post-toc-text">html</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#css"><span class="post-toc-number">2.</span> <span class="post-toc-text">css</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-css%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">1. css选择器及优先级</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-position-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2. position 属性的值以及区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-css-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">3. css 盒模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-%E6%80%8E%E4%B9%88%E8%A7%A6%E5%8F%91BFC%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">4. 怎么触发BFC，有什么应用场景？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-flex-%E5%B8%83%E5%B1%80"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">5. flex 布局</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-grid-%E5%B8%83%E5%B1%80"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">6. grid 布局</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%91%A2%EF%BC%9F"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">7. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JavaScript"><span class="post-toc-number">3.</span> <span class="post-toc-text">JavaScript</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-JavaScript-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1. JavaScript 都有哪些数据类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">2. 普通函数和箭头函数的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-reduce-%E7%94%A8%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">3. reduce 用法及实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-jQuery%E5%92%8Cvue%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">4. jQuery和vue什么区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C-DOM-%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">5. 为什么操作 DOM 会影响性能</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">6. 事件循环</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">7. 显示转换、隐式转换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-%E9%98%B2%E6%8A%96"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">8. 防抖</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-%E8%8A%82%E6%B5%81"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">9. 节流</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="post-toc-number">3.10.</span> <span class="post-toc-text">10. 深浅拷贝</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="post-toc-number">3.11.</span> <span class="post-toc-text">11. 原型和原型链</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of"><span class="post-toc-number">3.12.</span> <span class="post-toc-text">12. for…in 和 for…of</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="post-toc-number">3.13.</span> <span class="post-toc-text">13. 创建对象的各种方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="post-toc-number">3.13.1.</span> <span class="post-toc-text">new 操作符干了什么?</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">3.14.</span> <span class="post-toc-text">14. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15"><span class="post-toc-number">3.15.</span> <span class="post-toc-text">15.</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-js-%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-number">3.16.</span> <span class="post-toc-text">16. js 中字符串常用方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-number">3.17.</span> <span class="post-toc-text">17. 数组常用方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-JavaScript%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-number">3.18.</span> <span class="post-toc-text">18. JavaScript中执行上下文和执行栈是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="post-toc-number">3.19.</span> <span class="post-toc-text">19. 谈谈你对作用域和作用域链的理解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="post-toc-number">3.20.</span> <span class="post-toc-text">20. 变量对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85"><span class="post-toc-number">3.21.</span> <span class="post-toc-text">21. 说说你对闭包的理解，什么场景下使用闭包</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-this-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="post-toc-number">3.22.</span> <span class="post-toc-text">20. 谈谈你对 this 的理解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21-js-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="post-toc-number">3.23.</span> <span class="post-toc-text">21. js 中的事件模型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-typeof-%E5%92%8C-instanceof-%E5%8C%BA%E5%88%AB"><span class="post-toc-number">3.24.</span> <span class="post-toc-text">22. typeof 和 instanceof 区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#23-bind%E3%80%81call%E3%80%81apply-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-number">3.25.</span> <span class="post-toc-text">23. bind、call、apply 区别？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#24-%E6%89%8B%E5%86%99-bind%E3%80%81call%E3%80%81apply"><span class="post-toc-number">3.26.</span> <span class="post-toc-text">24. 手写 bind、call、apply</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#25-%E8%B0%88%E8%B0%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="post-toc-number">3.27.</span> <span class="post-toc-text">25. 谈谈单点登录</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ES6"><span class="post-toc-number">4.</span> <span class="post-toc-text">ES6</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-var%E3%80%81let%E3%80%81const-%E5%8C%BA%E5%88%AB"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">1. var、let、const 区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%8B-Set-%E5%92%8C-Map"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">2. 介绍下 Set 和 Map</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-promise"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">3. promise</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-class"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">4. class</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">类定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">类构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">静态方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95"><span class="post-toc-number">4.4.4.</span> <span class="post-toc-text">实例属性的新写法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">静态属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">私有方法和私有属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#new-target"><span class="post-toc-number">4.5.2.</span> <span class="post-toc-text">new.target</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="post-toc-number">4.5.3.</span> <span class="post-toc-text">继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-Proxy"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">5. Proxy</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-Iterator"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">6. Iterator</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-Generator"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">7. Generator</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-async"><span class="post-toc-number">4.9.</span> <span class="post-toc-text">8. async</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link"><span class="post-toc-number">4.10.</span> <span class="post-toc-text"></span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#vue"><span class="post-toc-number">5.</span> <span class="post-toc-text">vue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">1. 生命周期</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E7%88%B6%E5%AD%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">2. 父子生命周期顺序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">3. 父子组件传值</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-nextTick"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">4. nextTick</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-vue%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">5. vue的data为什么是函数返回而不是直接一个对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-v-if-%E5%92%8C-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">6. v-if 和 v-show 的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">7. computed 和 watch 的区别和运用的场景？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-%E8%AE%B2%E8%AE%B2-vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="post-toc-number">5.8.</span> <span class="post-toc-text">8. 讲讲 vue 响应式原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-%E8%AE%B2%E8%AE%B2%E8%99%9A%E6%8B%9F-dom"><span class="post-toc-number">5.9.</span> <span class="post-toc-text">9. 讲讲虚拟 dom</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-%E8%AE%B2%E8%AE%B2-diff-%E7%AE%97%E6%B3%95"><span class="post-toc-number">5.10.</span> <span class="post-toc-text">10. 讲讲 diff 算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88-vue-%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E7%BB%99%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC"><span class="post-toc-number">5.11.</span> <span class="post-toc-text">11. 为什么 vue 检测不到给数组项赋值</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="post-toc-number">5.12.</span> <span class="post-toc-text">12. 父组件如何监听子组件的生命周期</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-keep-alive-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="post-toc-number">5.13.</span> <span class="post-toc-text">13. 谈谈你对 keep-alive 的了解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-v-model-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="post-toc-number">5.14.</span> <span class="post-toc-text">14. v-model 的原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-vue-router-%E4%B8%AD-hash-%E5%92%8C-history-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="post-toc-number">5.15.</span> <span class="post-toc-text">15. vue-router 中 hash 和 history 路由模式实现原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-MVVM"><span class="post-toc-number">5.16.</span> <span class="post-toc-text">16. MVVM</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-Vue-%E4%B8%AD%E7%9A%84-key-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="post-toc-number">5.17.</span> <span class="post-toc-text">17. Vue 中的 key 有什么作用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-Vue-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="post-toc-number">5.18.</span> <span class="post-toc-text">18. Vue 性能优化方案</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-proxy-%E5%92%8C-Object-defineProperty-%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="post-toc-number">5.19.</span> <span class="post-toc-text">19. proxy 和 Object.defineProperty 优劣对比</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="post-toc-number">5.20.</span> <span class="post-toc-text">20. SPA首屏加载速度慢的怎么解决</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21"><span class="post-toc-number">5.21.</span> <span class="post-toc-text">21.</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#vuex"><span class="post-toc-number">6.</span> <span class="post-toc-text">vuex</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-Vuex%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88mutation%E4%B8%8D%E8%83%BD%E5%81%9A%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">1. Vuex有哪些基本属性，为什么mutation不能做异步操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#http"><span class="post-toc-number">7.</span> <span class="post-toc-text">http</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">1. 跨域解决方案</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">2. 强缓存和协商缓存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">3. 三次握手</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">4. 四次挥手</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-http-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">5. http 常见状态码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-HTTP-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">6. HTTP 请求报文结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="post-toc-number">8.</span> <span class="post-toc-text">浏览器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">1. 前端性能优化方案</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">2. 浏览器内核</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%9B%9E%E8%BD%A6%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E8%BF%87%E7%A8%8B"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">3. 从输入网址回车到页面显示过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-cookies%E3%80%81sessionStorage%E3%80%81localStorage-%E5%92%8C-indexDB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">4. cookies、sessionStorage、localStorage 和 indexDB 的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">5. 浏览器的渲染引擎工作原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98"><span class="post-toc-number">8.6.</span> <span class="post-toc-text">6. 重排和重绘</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91"><span class="post-toc-number">8.7.</span> <span class="post-toc-text">7. 哪些情况会导致重绘和重排，如何减少</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#webpack"><span class="post-toc-number">9.</span> <span class="post-toc-text">webpack</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">1. 说说你对webpack的理解？解决了什么问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">2. webpack的构建流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">3. webpack中常见的Loader？解决了什么问题？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">4. 说说webpack中常见的Plugin？解决了什么问题？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-%E8%AF%B4%E8%AF%B4Loader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">5. 说说Loader和Plugin的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-%E8%AF%B4%E8%AF%B4webpack%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-number">9.6.</span> <span class="post-toc-text">6. 说说webpack的热更新是如何做到的？原理是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-webpack-proxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="post-toc-number">9.7.</span> <span class="post-toc-text">7. webpack proxy工作原理？为什么能解决跨域</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="post-toc-number">9.8.</span> <span class="post-toc-text">8. 如何借助webpack来优化前端性能？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="post-toc-number">9.9.</span> <span class="post-toc-text">9. 如何提高webpack的构建速度</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%98%BF%E9%87%8C%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="post-toc-number">10.</span> <span class="post-toc-text">阿里成本管理系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E5%88%86%E9%85%8D%E7%9A%84"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">1. 如果实现权限分配的</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">2. 大数据表格的实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E6%A0%91%E5%BD%A2%E8%A1%A8%E6%A0%BC%E8%99%9A%E6%8B%9F%E6%B8%B2%E6%9F%93"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">3. 树形表格虚拟渲染</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E6%89%8B%E5%86%99%E9%87%91%E9%A2%9D%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0"><span class="post-toc-number">10.4.</span> <span class="post-toc-text">3. 手写金额格式化函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">10.5.</span> <span class="post-toc-text">4. 加减乘除的实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5"><span class="post-toc-number">10.6.</span> <span class="post-toc-text">5.</span></a></li></ol></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><span class="footer-msg">
Copyright &copy;
2020<span class="time-divide">-</span>2023
haibolian.

Power by
<a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>
and
<a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.0">Theme Yuzu</a>.</span></div></footer>
<script src="/js/clipboard/clipboard.min.js"></script>


<script src="/js/theme.js"></script>


<script src="/js/index.js"></script>

<script src="/js/toc.js"></script>
</div></body></html>